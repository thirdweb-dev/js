import { ArticleIconCard } from "@doc";
import { ReactIcon } from "@/icons";

# x402 payments

Implement paid API calls using the x402 protocol. Every request is paid for by the user with a micro payment onchain.

<ArticleIconCard
  title="x402 Playground"
  description="Try out a x402 payment in our live playground"
  icon={ReactIcon}
  href="https://playground.thirdweb.com/payments/x402"
/>

## Client Side

`wrapFetchWithPayment` wraps the native fetch API to automatically handle `402 Payment Required` responses from any API call. It will:
1. Make the initial request
2. If a 402 response is received, parse the payment requirements
3. Verify the payment amount is within the allowed maximum
4. Sign a payment authorization 
5. Create a payment header using the provided wallet signature
6. Retry the request with the payment header

Here's an example:

```typescript
import { wrapFetchWithPayment } from "thirdweb/x402";
import { createThirdwebClient } from "thirdweb";
import { createWallet } from "thirdweb/wallets";

const client = createThirdwebClient({ clientId: "your-client-id" });
const wallet = createWallet("io.metamask"); // or any other wallet
await wallet.connect({ client })

const fetchWithPay = wrapFetchWithPayment(fetch, client, wallet);

// Make a request that may require payment
const response = await fetchWithPay('https://api.example.com/paid-endpoint');
```

## Server Side

To make your API calls payable, you can use the `settlePayment` function in a middleware or in your endpoint directly.

Use the `facilitator` configuration function settle transactions with your thirdweb server wallet gaslessly and pass it to the `settlePayment` function.

Here's an example with a Next.js middleware:

```typescript
import { createThirdwebClient } from "thirdweb";
import { facilitator, settlePayment } from "thirdweb/x402";

const client = createThirdwebClient({ secretKey: "your-secret-key" });
const thirdwebX402Facilitator = facilitator({
  client,
  serverWalletAddress: "0xYourWalletAddress",
});

export async function middleware(request: NextRequest) {
  const method = request.method.toUpperCase();
  const resourceUrl = request.nextUrl.toString();
  const paymentData = request.headers.get("X-PAYMENT");

  const result = await settlePayment({
    resourceUrl,
    method,
    paymentData,
    payTo: "0xYourWalletAddress",
    network: "eip155:1", // or any other chain id in CAIP2 format: "eip155:<chain_id>"
    price: "$0.01", // can also be a ERC20 token amount
    routeConfig: {
      description: "Access to paid content",
    },
    facilitator: thirdwebX402Facilitator,
  });

  if (result.status === 200) {
    // payment successful, execute the request
    const response = NextResponse.next();
    // optionally set the response headers back to the client
    for (const [key, value] of Object.entries(result.responseHeaders)) {
      response.headers.set(key, value);
    }
    return response;
  }

  // otherwise, request payment
  return NextResponse.json(result.responseBody, {
    status: result.status,
    headers: result.responseHeaders,
  });
}

// Configure which paths the middleware should run on
export const config = {
  matcher: ["/api/paid-endpoint"],
};
```

You can also use the `verifyPayment` function to verify the payment before settling it. This lets you do the work that requires payment first and then settle the payment.
