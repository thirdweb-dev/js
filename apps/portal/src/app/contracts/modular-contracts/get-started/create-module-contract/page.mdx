// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Module} from "@thirdweb-dev/src/Module.sol";
import {Role} from "@thirdweb-dev/src/Role.sol";

contract BOPTokenModule is Module {
    library TokenStorage {
        bytes32 public constant TOKEN_STORAGE_POSITION = 
            keccak256(abi.encode("bop.token.storage"));

        struct Data {
            uint256 totalSupply;
            uint256 transactionFee; // in basis points (1% = 100)
            uint256 charityPercentage; // in basis points
            uint256 burnPercentage; // in basis points
            uint256 maxTransactionAmount; // Anti-whale limit
            address charityWallet;
            mapping(address => uint256) balances;
            mapping(address => mapping(address => uint256)) allowances;
            mapping(address => bool) isExcludedFromFees; // Exclude addresses from fees
        }

        function data() internal pure returns (Data storage data_) {
            bytes32 position = TOKEN_STORAGE_POSITION;
            assembly {
                data_.slot := position
            }
        }
    }

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function getModuleConfig()
        public
        pure
        override
        returns (ModuleConfig memory config)
    {
        config.callbackFunctions = new CallbackFunction      config.fallbackFunctions = new FallbackFunction ;

   config.callbackFunctions[0] = CallbackFunction(
            this.beforeTransfer.selector
        );

        config.fallbackFunctions[0] = FallbackFunction({
            selector: this.getTransactionFee.selector,
            permissionBits: 0
        });

        config.fallbackFunctions[1] = FallbackFunction({
            selector: this.getCharityPercentage.selector,
            permissionBits: 0
        });

        config.fallbackFunctions[2] = FallbackFunction({
            selector: this.getBurnPercentage.selector,
            permissionBits: 0
        });

        config.fallbackFunctions[3] = FallbackFunction({
            selector: this.getMaxTransactionAmount.selector,
            permissionBits: Role._MANAGER_ROLE
        });

        config.fallbackFunctions[4] = FallbackFunction({
            selector: this.setCharityWallet.selector,
            permissionBits: Role._MANAGER_ROLE
        });

        config.requiredInterfaces = new bytes4 ;
     nfig.requiredInterfaces[0] = 0x00000001;

        config.registerInstallationCallback = true;
    }

    function _storage() internal pure returns (TokenStorage.Data storage) {
        return TokenStorage.data();
    }

    // Governance Functions
    function setCharityWallet(address _wallet) external {
        require(_wallet != address(0), "Invalid address");
        _storage().charityWallet = _wallet;
    }

    function setTransactionFee(uint256 _fee) external {
        require(_fee <= 1000, "Fee too high"); // Max 10%
        _storage().transactionFee = _fee;
    }

    function setCharityPercentage(uint256 _percentage) external {
        require(_percentage <= 5000, "Charity too high"); // Max 50%
        _storage().charityPercentage = _percentage;
    }

    function setBurnPercentage(uint256 _percentage) external {
        require(_percentage <= 1000, "Burn too high"); // Max 10%
        _storage().burnPercentage = _percentage;
    }

    function setMaxTransactionAmount(uint256 _amount) external {
        _storage().maxTransactionAmount = _amount;
    }

    // Token Functions
    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        _storage().allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool) {
        require(
            _storage().allowances[from][msg.sender] >= amount,
            "Allowance exceeded"
        );
        _storage().allowances[from][msg.sender] -= amount;
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        TokenStorage.Data storage s = _storage();

        require(
            amount <= s.maxTransactionAmount || s.isExcludedFromFees[from],
            "Transaction exceeds max limit"
        );
        require(s.balances[from] >= amount, "Insufficient balance");

        uint256 fee = (amount * s.transactionFee) / 10000;
        uint256 charity = (fee * s.charityPercentage) / 10000;
        uint256 burn = (fee * s.burnPercentage) / 10000;
        uint256 transferAmount = amount - fee;

        s.balances[from] -= amount;
        s.balances[to] += transferAmount;
        s.balances[s.charityWallet] += charity;

        // Burn the tokens
        s.totalSupply -= burn;

        emit Transfer(from, to, transferAmount);
        emit Transfer(from, s.charityWallet, charity);
    }

    function balanceOf(address account) external view returns (uint256) {
        return _storage().balances[account];
    }

    function allowance(address owner, address spender)
        external
        view
        returns (uint256)
    {
        return _storage().allowances[owner][spender];
    }
}
