import { DocImage, Callout, createMetadata, Tabs, TabsList, TabsContent, TabsTrigger } from "@doc";
import EnclaveWalletCreation from "./assets/enclave-wallet-creation.png";
import AppScoped from "./assets/app-scoped.svg";
import EcosystemScoped from "./assets/ecosystem-scoped.svg";

export const metadata = createMetadata({
	image: {
		title: "Wallet Security",
		icon: "wallets",
	},
	title: "Wallet Security & Architecture | thirdweb Documentation",
	description:
		"Learn how thirdweb protects your user's private keys across applications using nitro Enclaves",
});

# Wallet Security & Architecture

<Tabs defaultValue="user-wallets">
  <TabsList>
    <TabsTrigger value="user-wallets" className="flex items-center [&>p]:mb-0">
      User Wallets
    </TabsTrigger>
     <TabsTrigger value="server-wallets" className="flex items-center [&>p]:mb-0">
      Server Wallets
    </TabsTrigger>
    <TabsTrigger value="audits" className="flex items-center [&>p]:mb-0">
      Audits
    </TabsTrigger>
  </TabsList>
  <TabsContent value="user-wallets">

## Wallet Creation

When a user signs into an application using their email or social logins for the first time, a wallet is generated within a secure enclave on the server after verifying the user's legitimacy. The enclave provides a trusted execution environment, ensuring the wallet creation process is isolated and protected from external interference.

- The wallet and its corresponding private key are generated entirely within the enclave, never leaving its secure confines.
- User authentication data is verified within the enclave, ensuring that only legitimate, authenticated users can initiate wallet creation.

<DocImage src={EnclaveWalletCreation} className="max-w-96" />


## Security Measures

- The enclave's cryptographic properties ensure that even the server operators cannot access the contents or operations within the enclave.
- The enclave provides a verifiable hash of the image of the code that is being run on the device, allowing anyone to verify the contents of the code.
- The wallet's private key never exists in an unencrypted form outside of the enclave.
- All sensitive operations, such as transaction signing, occur within the enclave, ensuring the wallet's security.

### General Usage

- When users interact with their wallet via the enclave, all communications are encrypted and only the legitimate user can access their wallet.
- All traffic is encrypted with TLS and HSTS. Services are run in private VPCs on AWS and accessible only from a single entry point via our Cloudflare DNS.
- Applications can [link multiple authentication methods](/wallets/link-profiles) to the same wallet. Any of these methods can be used to authenticate into the users wallet.

### Ecosystem Usage

Ecosystem wallets are controlled by the ecosystem owner. Ecosystem owners are able to specify usage policies for their partners and developers which restricts what they can do with the wallet. Unlike the shamir secret sharing model, the enclave wallet model ensures that the private key is never reconstructed on the client. This ensures no-one can extract the private key from the client, including other developers in the ecosystem. Moreover, it also means that partners and developers must submit the request to the enclave which would be able to verify the request and block requests that are out of scope or denied by the ecosystem owner.  
 
### In App Wallets

In-App Wallets are scoped to applications per Client ID. If users use the same email to sign in to a different application using In-App Wallets, the application will manage an entirely different wallet.

#### Benefits of single application scoped wallets

- Each application has limited access only to wallets created through their application. It cannot manage wallets from other applications.
- Users may only view tokens sent or purchased from your application.
- To improve user experience, saved payment methods and KYC verification are only provided to thirdweb; applications cannot view this information.

<DocImage src={AppScoped} />

### Ecosystem Wallets

Ecosystem Wallets are scoped to the ecosystem. If users use the same email to sign in to a different application using the same ecosystem, they will get the same wallet.

#### Benefits of ecosystem scoped wallets

- Applications can now share assets across various applications. This is useful if you're a brand powering multiple application and want your partners to take advantage of network effects.
- Application owner has full control over what happens within each application. This is useful if you're a brand that wants to ensure that all applications in your ecosystem are following the same rules.

<DocImage src={EcosystemScoped} />


## Recoverability

- Users can export their private key at any time. 
- Users may recover their wallet from any device by authenticating or signing into an application to receive access to their wallet.
- Thirdweb wallets support four categories of authentication: socials, custom authentication, external wallets, and email / phone authentication. If a user ever loses access to their authentication method:

  1.  **For socials and email / phone authentication,** users can utilize the recovery flow of their providers to regain access to their account.
  2.  **In the case of custom authentication,** the developer managing their authentication flow will be able to re-instate the users account upon successful verification.
  3.  Application providers **do not have direct access** to user accounts or private keys, as these remain secured within the enclave. The enclave's design ensures that only verified user requests can trigger wallet operations.

- Users are able to link their authentication methods which will provide them multiple ways to access their account if they ever lose access to any one of their authentication method.

## Security & privacy

### TLS Encryption

To increase security and privacy, private keys or wallet "seed phrases" are never stored or sent over a network. TLS encryption is used in transit for internal and external communications with thirdweb's back-end and databases. TLS encryption is also required for third-party vendors.

### AES-256

Data backups and storage are encrypted with AES-256.

### GDPR & CCPA

thirdweb complies to GDPR and CCPA compliance frameworks and deletes customer data per request within the required timeframe of each standard (30 days for GDPR and 45 for CCPA).

### Audit and Bounty Program

Halborn has audited our enclave wallet security architecture which we'll be releasing shortly, and there is an ongoing bounty program to ensure vulnerabilities are caught. [View the Letter of Attestation.](/pdfs/thirdweb_code_security_audit.pdf)

</TabsContent>

<TabsContent value="server-wallets">
## Non Custodiality
Vault guarantees non-custodiality through cryptography. All private and sensitive data is stored encrypted, and can only be decrypted within the secure enclave. The code running within the secure enclave is open-source, audited, and attested.

## Attestation
At any time, you can request an attestation document from Vault. This attestation document is signed by AWS (independently verifiable).

The attestation document allows you to verify that the code being run inside the secure enclave has not been tampered, and is the same as the open source code that you can access.

The code running inside a nitro enclave is an Enclave Image File (EIF). The EIF has unique PCR values which will change upon tampering.

In the context of AWS Nitro Enclaves, an Enclave Image File (EIF) measurement, specifically the Platform Configuration Register (PCR) values, are cryptographic hashes that uniquely identify the enclave's image and its contents. PCRs are used to verify that the enclave has been loaded and is running in a known, trusted state, ensuring its integrity and preventing unauthorized modification

The master key of the Vault can only be accessed by this exact code running inside the enclave. To verify this, you can query Vault to check the current AWS policy on the master key, and confirm that only nitro-enclaves with this specific PCR measurement have access to these resources.

## Verify, Don’t Trust
You can compile your own EIF from the Vault source-code, and retrieve PCR values. This allows you to compare the PCR values you received from Vault against the PCR measurements you generated yourself, proving that a hosted Vault service is running untampered code.

## Chain of Verification
Armed with proof that the Vault service is running untampered code, you can audit the code to ensure Vault behaves as expected.

For example: how can you verify that Vault is not lying about who can access it’s keys?

You can look at the Vault code to confirm that it does indeed query the correct AWS APIs to fetch the current policies on it’s keys, and then returns it without modifications.

If you know the code is correct, and if you know that the service is running untampered code, then you can confirm that the correct data is being returned to you.

But how can you confirm that data from the Vault hasn’t been tampered by other non-enclave components your response might be coming through? To solve this, Vault uses an end to end encrypted communication protocol with perfect forward secrecy.

This same approach can be used to verify that all entities are always stored encrypted, and access is only granted to authorized requests. To further prevent data leakage, Vault uses HMAC hashes instead of raw identifiers to associate entities with each other in the encrypted database. This means Vault can not-only guarantee non-custodial access to entities, but also preserves privacy between entities and their owners. E2E encryption also means that all your operations and responses remain private and untampered.

## End to End Encryption
Every sensitive request to Vault is made to the `/v1/enclave/post` endpoint with a payload that looks like this:

```
{
  "ephemeralPublicKey": "05d7deb3ef80f929ee6d1afdbf63d43e68ae9d1a045577cf6a2cbc29baaa5c5f",
  "nonce": "716d11684ed4a973ff401e9bc84db48608c1f78abdba59a2",
  "ciphertext": "ed0665497121ca59ef610f976f0a3beaa494c17b65ca127e72f286fa3464fde3f14e305d9fded6090bd5fd7fd2fd57d93d399619fe950d71790daec1b753d5b221d914e6e29c6734e6a38c7d237a91fea289f4812eeefae88281cc9cae8e7421ca1d81a5ac4181d889a9a082fbaf7cd5c650a2c8ccf61981d9fc3535a76733e0b00dbad4a2492c399b8a49c00f89d11283fe408754e470f5ec3579fac2aedc4c042eb75dd6804cf0fa331d5da039cfad6e36f5d00e7c6e78b5e0956a36af01761c31b0d85d90b3d15e0808a544c3f15ba1d3ae108efd36add25791ee6d27d58d9bf7c87903bbd5c54ed52c3b501eb9c67ff374308d95b7acabd7e02375fd0aab6668008583740f1883ed0c00731f732ecd4d46498939f223b1eba1c0c536cea12cf85370c17ef30fce992c129938e1f049c64c2cadafd1efc93692445c47923f6bb9ffbb8226fbf7f5bfa5a14060a2085c1df145294397a7035761c20fdac820a57ed4bdd591941a9d9804c3c92c1e5e0f60857a68516b330816c57e133b4dfcf492cdc1f9ab3d9097babd997552adbb90c871e82fbab041555f0ab4ae3fb93adf4a3ba2182d76787d58568275849595564eb10e601f7ede972f2c6d8429112f90ce4aa09177ca2811d7025100cd3621edcc8b091d2e943afdc44f91d2f60abb3daae1"
}
```

The communication protocol ensures that requests can only be decrypted by the Vault-enclave, and responses can only be decrypted by you. The protocol also provides perfect forward secrecy, meaning even if cryptographic keys for a previous request is exposed, future requests still remain non-compromised.

### Protocol
Vault uses the xChaCha20Poly1305 cryptographic cipher, combined with the x25519dalek for zero round trip key-exchange.

**Step 1**
The client queries the Vault’s xChaCha20Poly1305 public-key from the `GET api/v1/enclave` endpoint.

**Step 2**
The client generates a random 32 byte ephemeral secret key (and stores it to decrypt the response too)

**Step 3**
The client derives a shared secret using xChaCha20Poly1305:

```shared_secret = diffie_hellman(client_ephemeral_secret_key, vault_public_key)```

**Step 4**
The client derives an encryption key from the `shared_secret` using HKDF

**Step 5**
The client generates a random 24 byte nonce

The client generates the `ciphertext` using xChaCha20Poly1305 with the random nonce, and the derives encryption key

**Sending the Payload**
The generated ciphertext, nonce, and the public key to the ephemeral secret are all hex encoded and sent as the payload

**Decrypting the Response**
The response also arrives in the same payload format. We just perform the steps in reverse now.

1. Use `x25519dalek` `diffie_hellman` to derive a shared_secret from the:
- private key we used for sending the request
- the public key returned in the response
2. HKDF the `shared_secret` to get the `encryption_key`
3. Use the `nonce` in the response (which Vault randomly generates) + the `shared_secret` with xChaCha20Poly1305 to decrypt your payload.

</TabsContent>

<TabsContent value="audits">

## Wallets Audits

View the full audit reports for any wallets-related features and specs:

- [7702 (Minimal Account)](https://0xmacro.com/library/audits/thirdweb-22)
- [Managed Account Factory](https://ipfs.io/ipfs/Qmc36VUCuwG2u7kZrqmXmJsH5c8sF7SHySVbPnwVmo3XYX/thirdweb%20A-14%20_%20Macro%20Audits%20_%20The%200xMacro%20Library.pdf)
</TabsContent>

</Tabs>