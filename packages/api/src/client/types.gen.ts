// This file is auto-generated by @hey-api/openapi-ts

export type InitiateAuthenticationData = {
	/**
	 * Authentication Initiate Request
	 * Request to initiate authentication flow. Choose one of the supported authentication methods: sms, email, oauth, passkey, or siwe. The required fields depend on the authentication method selected.
	 */
	body?:
		| {
				/**
				 * Authentication method: SMS
				 */
				method: "sms";
				/**
				 * Phone number in E.164 format (e.g., +1234567890)
				 */
				phone: string;
		  }
		| {
				/**
				 * Authentication method: Email
				 */
				method: "email";
				/**
				 * Email address for verification code
				 */
				email: string;
		  }
		| {
				/**
				 * Authentication method: OAuth
				 */
				method: "oauth";
				/**
				 * Social login provider
				 */
				provider:
					| "google"
					| "apple"
					| "facebook"
					| "discord"
					| "farcaster"
					| "telegram"
					| "line"
					| "x"
					| "coinbase"
					| "github"
					| "twitch"
					| "steam"
					| "tiktok";
				/**
				 * Custom redirect URL after OAuth completion
				 */
				redirectUrl?: string;
		  }
		| {
				/**
				 * Authentication method: Passkey
				 */
				method: "passkey";
				/**
				 * Whether to create a new passkey or use existing one
				 */
				type: "sign-up" | "sign-in";
				/**
				 * Username for passkey (optional, for identification)
				 */
				username?: string;
		  }
		| {
				/**
				 * Authentication method: Sign-In with Ethereum
				 */
				method: "siwe";
				/**
				 * Ethereum wallet address for SIWE
				 */
				address: string;
				/**
				 * Chain ID for SIWE (defaults to 1)
				 */
				chainId?: number;
		  };
	path?: never;
	query?: never;
	url: "/v1/auth/initiate";
};

export type InitiateAuthenticationErrors = {
	/**
	 * Invalid request - Check your method and parameters
	 */
	400: unknown;
	/**
	 * Rate limit exceeded - Please wait before trying again
	 */
	429: unknown;
};

export type InitiateAuthenticationResponses = {
	/**
	 * Authentication Initiate Response
	 * Response from authentication initiation. Contains method-specific data needed to complete authentication.
	 */
	200:
		| {
				/**
				 * Authentication method: SMS
				 */
				method: "sms";
				/**
				 * Whether the SMS code was sent successfully
				 */
				success: boolean;
		  }
		| {
				/**
				 * Authentication method: Email
				 */
				method: "email";
				/**
				 * Whether the email code was sent successfully
				 */
				success: boolean;
		  }
		| {
				/**
				 * Authentication method: OAuth
				 */
				method: "oauth";
				/**
				 * URL to redirect user for OAuth authentication
				 */
				redirectUrl: string;
		  }
		| {
				/**
				 * Authentication method: Passkey
				 */
				method: "passkey";
				/**
				 * Server verification ID for passkey
				 */
				serverVerificationId: string;
				/**
				 * Base64-encoded WebAuthn challenge
				 */
				challenge: string;
				/**
				 * Challenge type (sign-up or sign-in)
				 */
				type: string;
		  }
		| {
				/**
				 * Authentication method: Sign-In with Ethereum
				 */
				method: "siwe";
				/**
				 * SIWE message string to be signed
				 */
				payload: string;
		  };
};

export type InitiateAuthenticationResponse =
	InitiateAuthenticationResponses[keyof InitiateAuthenticationResponses];

export type CompleteAuthenticationData = {
	/**
	 * Authentication Complete Request
	 * Request to complete authentication flow. Choose the same method used in initiate: sms, email, oauth, passkey, siwe, guest, or custom. The required fields depend on the authentication method.
	 */
	body?:
		| {
				/**
				 * Authentication method: SMS
				 */
				method: "sms";
				/**
				 * Phone number that received the code
				 */
				phone: string;
				/**
				 * Verification code received via SMS
				 */
				code: string;
		  }
		| {
				/**
				 * Authentication method: Email
				 */
				method: "email";
				/**
				 * Email address that received the code
				 */
				email: string;
				/**
				 * Verification code received via email
				 */
				code: string;
		  }
		| {
				/**
				 * Authentication method: Passkey
				 */
				method: "passkey";
				/**
				 * Passkey operation type
				 */
				type: "sign-up" | "sign-in";
				/**
				 * Base64-encoded authenticator data
				 */
				authenticatorData: string;
				/**
				 * Base64-encoded credential ID
				 */
				credentialId: string;
				/**
				 * Server verification ID from initiate response
				 */
				serverVerificationId: string;
				/**
				 * Base64-encoded client data JSON
				 */
				clientData: string;
				/**
				 * Base64-encoded signature (for sign-in)
				 */
				signature?: string;
				/**
				 * Origin of the request
				 */
				origin?: string;
				/**
				 * Relying party identifier
				 */
				rpId?: string;
				/**
				 * Username for the passkey
				 */
				username?: string;
				/**
				 * Credential data for passkey registration
				 */
				credential?: {
					/**
					 * Public key for the credential
					 */
					publicKey: string;
					/**
					 * Algorithm used for the credential
					 */
					algorithm: "RS256" | "ES256";
				};
		  }
		| {
				/**
				 * Authentication method: Sign-In with Ethereum
				 */
				method: "siwe";
				/**
				 * Hex-encoded signed SIWE message
				 */
				signature: string;
				/**
				 * The original SIWE payload that was signed
				 */
				payload: string;
		  }
		| {
				/**
				 * Authentication method: Custom
				 */
				method: "custom";
				/**
				 * Custom authentication type
				 */
				type: "jwt" | "auth-payload";
				/**
				 * JWT token for OIDC authentication
				 */
				jwt?: unknown;
				/**
				 * Custom authentication payload
				 */
				payload?: unknown;
		  }
		| {
				/**
				 * Authentication method: Guest
				 */
				method: "guest";
				/**
				 * Optional guest session ID - if not provided, a random one will be generated with no persistence guarantees.
				 */
				sessionId?: string;
		  };
	path?: never;
	query?: never;
	url: "/v1/auth/complete";
};

export type CompleteAuthenticationErrors = {
	/**
	 * Invalid credentials or request - Check your challenge ID and verification data
	 */
	400: unknown;
	/**
	 * Rate limit exceeded - Please wait before trying again
	 */
	429: unknown;
};

export type CompleteAuthenticationResponses = {
	/**
	 * Successful authentication response. Returns wallet address plus authentication tokens.
	 */
	200: {
		/**
		 * Whether this is a newly created user/wallet
		 */
		isNewUser: boolean;
		/**
		 * JWT authentication token for API access
		 */
		token: string;
		/**
		 * Type of authentication completed
		 */
		type: string;
		/**
		 * The wallet address
		 */
		walletAddress: string;
	};
};

export type CompleteAuthenticationResponse =
	CompleteAuthenticationResponses[keyof CompleteAuthenticationResponses];

export type SocialAuthenticationData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The OAuth provider to use
		 */
		provider:
			| "google"
			| "apple"
			| "facebook"
			| "discord"
			| "farcaster"
			| "telegram"
			| "line"
			| "x"
			| "coinbase"
			| "github"
			| "twitch"
			| "steam"
			| "tiktok";
		/**
		 * URL to redirect the user to after OAuth completion
		 */
		redirectUrl: string;
		/**
		 * Client ID (alternative to x-client-id header for standard OAuth flows)
		 */
		clientId?: string;
	};
	url: "/v1/auth/social";
};

export type SocialAuthenticationErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
};

export type GetMyWalletData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v1/wallets/me";
};

export type GetMyWalletErrors = {
	/**
	 * Authentication required. The request must include a valid `Authorization: Bearer <jwt>` header.
	 */
	401: unknown;
	/**
	 * Wallet not found. The authenticated user does not exist in the system.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type GetMyWalletResponses = {
	/**
	 * Wallet retrieved successfully. Returns comprehensive user information including wallet addresses, public key, and linked wallets.
	 */
	200: {
		result: {
			/**
			 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
			 */
			address?: string;
			/**
			 * The date and time the wallet was created
			 */
			createdAt?: string;
			/**
			 * AuthenticationProviderDetail
			 * Authentication provider details with type-based discrimination
			 */
			profiles: Array<
				| {
						email: string;
						emailVerified: boolean;
						familyName?: string;
						givenName?: string;
						hd: string;
						id: string;
						locale: string;
						name?: string;
						picture: string;
						type: "google";
				  }
				| {
						email?: string;
						firstName?: string;
						id: string;
						lastName?: string;
						name?: string;
						picture?: string;
						type: "facebook";
				  }
				| {
						email?: string;
						emailVerified: boolean;
						id: string;
						isPrivateEmail: boolean;
						type: "apple";
				  }
				| {
						avatar?: string;
						id: string;
						name?: string;
						type: "github";
						username: string;
				  }
				| {
						avatar: string;
						email?: string;
						emailVerified: boolean;
						id: string;
						type: "discord";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						name: string;
						type: "coinbase";
				  }
				| {
						id: string;
						name: string;
						type: "x";
						username: string;
						profileImageUrl?: string;
				  }
				| {
						id: string;
						displayName: string;
						avatarUrl: string;
						unionId?: string;
						type: "tiktok";
				  }
				| {
						avatar?: string;
						id: string;
						metadata: {
							avatar: {
								large?: string;
								medium?: string;
								small?: string;
							};
							personaname?: string;
							profileurl?: string;
							realname?: string;
						};
						type: "steam";
						username?: string;
				  }
				| {
						firstName?: string;
						id: string;
						lastName?: string;
						picture?: string;
						type: "telegram";
						username?: string;
				  }
				| {
						avatar?: string;
						description?: string;
						email?: string;
						id: string;
						type: "twitch";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						type: "line";
						username?: string;
				  }
				| {
						fid: string;
						id: string;
						type: "farcaster";
						walletAddress?: string;
				  }
				| {
						algorithm: string;
						credentialId: string;
						publicKey: string;
						type: "passkey";
				  }
				| {
						email: string;
						id: string;
						type: "email";
				  }
				| {
						id: string;
						pregeneratedIdentifier: string;
						type: "pre_generation";
				  }
				| {
						id: string;
						phone: string;
						type: "phone";
				  }
				| {
						id: string;
						type: "siwe";
						walletAddress: string;
				  }
				| {
						id: string;
						type: "guest";
				  }
				| {
						id: string;
						type: "backend";
				  }
				| {
						identifier: string;
						type: "server";
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_jwt";
						walletAddress?: string;
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_auth_endpoint";
						walletAddress?: string;
				  }
			>;
			/**
			 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
			 */
			smartWalletAddress?: string;
			/**
			 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
			 */
			publicKey?: string;
		};
	};
};

export type GetMyWalletResponse =
	GetMyWalletResponses[keyof GetMyWalletResponses];

export type ListUserWalletsData = {
	body?: never;
	path?: never;
	query?: {
		limit?: number;
		page?: number;
		email?: string;
		phone?: string;
		address?: string;
		externalWalletAddress?: string;
		id?: string;
	};
	url: "/v1/wallets/user";
};

export type ListUserWalletsErrors = {
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type ListUserWalletsResponses = {
	/**
	 * Returns a list of user wallet addresses, smart wallet addresses, and auth details.
	 */
	200: {
		result: {
			/**
			 * Pagination information
			 */
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of user wallets
			 */
			wallets: Array<{
				/**
				 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
				 */
				address?: string;
				/**
				 * The date and time the wallet was created
				 */
				createdAt?: string;
				/**
				 * AuthenticationProviderDetail
				 * Authentication provider details with type-based discrimination
				 */
				profiles: Array<
					| {
							email: string;
							emailVerified: boolean;
							familyName?: string;
							givenName?: string;
							hd: string;
							id: string;
							locale: string;
							name?: string;
							picture: string;
							type: "google";
					  }
					| {
							email?: string;
							firstName?: string;
							id: string;
							lastName?: string;
							name?: string;
							picture?: string;
							type: "facebook";
					  }
					| {
							email?: string;
							emailVerified: boolean;
							id: string;
							isPrivateEmail: boolean;
							type: "apple";
					  }
					| {
							avatar?: string;
							id: string;
							name?: string;
							type: "github";
							username: string;
					  }
					| {
							avatar: string;
							email?: string;
							emailVerified: boolean;
							id: string;
							type: "discord";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							name: string;
							type: "coinbase";
					  }
					| {
							id: string;
							name: string;
							type: "x";
							username: string;
							profileImageUrl?: string;
					  }
					| {
							id: string;
							displayName: string;
							avatarUrl: string;
							unionId?: string;
							type: "tiktok";
					  }
					| {
							avatar?: string;
							id: string;
							metadata: {
								avatar: {
									large?: string;
									medium?: string;
									small?: string;
								};
								personaname?: string;
								profileurl?: string;
								realname?: string;
							};
							type: "steam";
							username?: string;
					  }
					| {
							firstName?: string;
							id: string;
							lastName?: string;
							picture?: string;
							type: "telegram";
							username?: string;
					  }
					| {
							avatar?: string;
							description?: string;
							email?: string;
							id: string;
							type: "twitch";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							type: "line";
							username?: string;
					  }
					| {
							fid: string;
							id: string;
							type: "farcaster";
							walletAddress?: string;
					  }
					| {
							algorithm: string;
							credentialId: string;
							publicKey: string;
							type: "passkey";
					  }
					| {
							email: string;
							id: string;
							type: "email";
					  }
					| {
							id: string;
							pregeneratedIdentifier: string;
							type: "pre_generation";
					  }
					| {
							id: string;
							phone: string;
							type: "phone";
					  }
					| {
							id: string;
							type: "siwe";
							walletAddress: string;
					  }
					| {
							id: string;
							type: "guest";
					  }
					| {
							id: string;
							type: "backend";
					  }
					| {
							identifier: string;
							type: "server";
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_jwt";
							walletAddress?: string;
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_auth_endpoint";
							walletAddress?: string;
					  }
				>;
				/**
				 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
				 */
				smartWalletAddress?: string;
				/**
				 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
				 */
				publicKey?: string;
			}>;
		};
	};
};

export type ListUserWalletsResponse =
	ListUserWalletsResponses[keyof ListUserWalletsResponses];

export type CreateUserWalletData = {
	/**
	 * Request body for pre-generating a wallet
	 */
	body?: {
		type:
			| "google"
			| "apple"
			| "facebook"
			| "discord"
			| "email"
			| "phone"
			| "custom_auth_endpoint"
			| "custom_jwt"
			| "siwe";
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		walletAddress?: string;
		email?: string;
		phone?: string;
		userId?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/user";
};

export type CreateUserWalletErrors = {
	/**
	 * Invalid request. This may occur due to missing required fields based on the authentication strategy, invalid strategy, or malformed request data.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type CreateUserWalletResponses = {
	/**
	 * Successfully created a user wallet with wallet.
	 */
	200: {
		result: {
			/**
			 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
			 */
			address?: string;
			/**
			 * The date and time the wallet was created
			 */
			createdAt?: string;
			/**
			 * AuthenticationProviderDetail
			 * Authentication provider details with type-based discrimination
			 */
			profiles: Array<
				| {
						email: string;
						emailVerified: boolean;
						familyName?: string;
						givenName?: string;
						hd: string;
						id: string;
						locale: string;
						name?: string;
						picture: string;
						type: "google";
				  }
				| {
						email?: string;
						firstName?: string;
						id: string;
						lastName?: string;
						name?: string;
						picture?: string;
						type: "facebook";
				  }
				| {
						email?: string;
						emailVerified: boolean;
						id: string;
						isPrivateEmail: boolean;
						type: "apple";
				  }
				| {
						avatar?: string;
						id: string;
						name?: string;
						type: "github";
						username: string;
				  }
				| {
						avatar: string;
						email?: string;
						emailVerified: boolean;
						id: string;
						type: "discord";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						name: string;
						type: "coinbase";
				  }
				| {
						id: string;
						name: string;
						type: "x";
						username: string;
						profileImageUrl?: string;
				  }
				| {
						id: string;
						displayName: string;
						avatarUrl: string;
						unionId?: string;
						type: "tiktok";
				  }
				| {
						avatar?: string;
						id: string;
						metadata: {
							avatar: {
								large?: string;
								medium?: string;
								small?: string;
							};
							personaname?: string;
							profileurl?: string;
							realname?: string;
						};
						type: "steam";
						username?: string;
				  }
				| {
						firstName?: string;
						id: string;
						lastName?: string;
						picture?: string;
						type: "telegram";
						username?: string;
				  }
				| {
						avatar?: string;
						description?: string;
						email?: string;
						id: string;
						type: "twitch";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						type: "line";
						username?: string;
				  }
				| {
						fid: string;
						id: string;
						type: "farcaster";
						walletAddress?: string;
				  }
				| {
						algorithm: string;
						credentialId: string;
						publicKey: string;
						type: "passkey";
				  }
				| {
						email: string;
						id: string;
						type: "email";
				  }
				| {
						id: string;
						pregeneratedIdentifier: string;
						type: "pre_generation";
				  }
				| {
						id: string;
						phone: string;
						type: "phone";
				  }
				| {
						id: string;
						type: "siwe";
						walletAddress: string;
				  }
				| {
						id: string;
						type: "guest";
				  }
				| {
						id: string;
						type: "backend";
				  }
				| {
						identifier: string;
						type: "server";
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_jwt";
						walletAddress?: string;
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_auth_endpoint";
						walletAddress?: string;
				  }
			>;
			/**
			 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
			 */
			smartWalletAddress?: string;
			/**
			 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
			 */
			publicKey?: string;
		};
	};
};

export type CreateUserWalletResponse =
	CreateUserWalletResponses[keyof CreateUserWalletResponses];

export type ListServerWalletsData = {
	body?: never;
	path?: never;
	query?: {
		limit?: number;
		page?: number;
	};
	url: "/v1/wallets/server";
};

export type ListServerWalletsErrors = {
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type ListServerWalletsResponses = {
	/**
	 * Returns a list of server wallet addresses, smart wallet addresses, and auth details.
	 */
	200: {
		result: {
			/**
			 * Pagination information
			 */
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of server wallets
			 */
			wallets: Array<{
				/**
				 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
				 */
				address?: string;
				/**
				 * The date and time the wallet was created
				 */
				createdAt?: string;
				/**
				 * AuthenticationProviderDetail
				 * Authentication provider details with type-based discrimination
				 */
				profiles: Array<
					| {
							email: string;
							emailVerified: boolean;
							familyName?: string;
							givenName?: string;
							hd: string;
							id: string;
							locale: string;
							name?: string;
							picture: string;
							type: "google";
					  }
					| {
							email?: string;
							firstName?: string;
							id: string;
							lastName?: string;
							name?: string;
							picture?: string;
							type: "facebook";
					  }
					| {
							email?: string;
							emailVerified: boolean;
							id: string;
							isPrivateEmail: boolean;
							type: "apple";
					  }
					| {
							avatar?: string;
							id: string;
							name?: string;
							type: "github";
							username: string;
					  }
					| {
							avatar: string;
							email?: string;
							emailVerified: boolean;
							id: string;
							type: "discord";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							name: string;
							type: "coinbase";
					  }
					| {
							id: string;
							name: string;
							type: "x";
							username: string;
							profileImageUrl?: string;
					  }
					| {
							id: string;
							displayName: string;
							avatarUrl: string;
							unionId?: string;
							type: "tiktok";
					  }
					| {
							avatar?: string;
							id: string;
							metadata: {
								avatar: {
									large?: string;
									medium?: string;
									small?: string;
								};
								personaname?: string;
								profileurl?: string;
								realname?: string;
							};
							type: "steam";
							username?: string;
					  }
					| {
							firstName?: string;
							id: string;
							lastName?: string;
							picture?: string;
							type: "telegram";
							username?: string;
					  }
					| {
							avatar?: string;
							description?: string;
							email?: string;
							id: string;
							type: "twitch";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							type: "line";
							username?: string;
					  }
					| {
							fid: string;
							id: string;
							type: "farcaster";
							walletAddress?: string;
					  }
					| {
							algorithm: string;
							credentialId: string;
							publicKey: string;
							type: "passkey";
					  }
					| {
							email: string;
							id: string;
							type: "email";
					  }
					| {
							id: string;
							pregeneratedIdentifier: string;
							type: "pre_generation";
					  }
					| {
							id: string;
							phone: string;
							type: "phone";
					  }
					| {
							id: string;
							type: "siwe";
							walletAddress: string;
					  }
					| {
							id: string;
							type: "guest";
					  }
					| {
							id: string;
							type: "backend";
					  }
					| {
							identifier: string;
							type: "server";
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_jwt";
							walletAddress?: string;
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_auth_endpoint";
							walletAddress?: string;
					  }
				>;
				/**
				 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
				 */
				smartWalletAddress?: string;
				/**
				 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
				 */
				publicKey?: string;
			}>;
		};
	};
};

export type ListServerWalletsResponse =
	ListServerWalletsResponses[keyof ListServerWalletsResponses];

export type CreateServerWalletData = {
	/**
	 * Request body for creating a wallet
	 */
	body?: {
		/**
		 * Unique identifier for wallet creation or retrieval. Can be user ID, email, or any unique string. The same identifier will always return the same wallet.
		 */
		identifier: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/server";
};

export type CreateServerWalletErrors = {
	/**
	 * Invalid request parameters. This occurs when the identifier format is invalid or required parameters are missing.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet service unavailability, smart wallet deployment issues, or unexpected server errors.
	 */
	500: unknown;
};

export type CreateServerWalletResponses = {
	/**
	 * Server wallet created or connected successfully. Returns wallet addresses for subsequent operations.
	 */
	200: {
		result: {
			/**
			 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
			 */
			address?: string;
			/**
			 * The date and time the wallet was created
			 */
			createdAt?: string;
			/**
			 * AuthenticationProviderDetail
			 * Authentication provider details with type-based discrimination
			 */
			profiles: Array<
				| {
						email: string;
						emailVerified: boolean;
						familyName?: string;
						givenName?: string;
						hd: string;
						id: string;
						locale: string;
						name?: string;
						picture: string;
						type: "google";
				  }
				| {
						email?: string;
						firstName?: string;
						id: string;
						lastName?: string;
						name?: string;
						picture?: string;
						type: "facebook";
				  }
				| {
						email?: string;
						emailVerified: boolean;
						id: string;
						isPrivateEmail: boolean;
						type: "apple";
				  }
				| {
						avatar?: string;
						id: string;
						name?: string;
						type: "github";
						username: string;
				  }
				| {
						avatar: string;
						email?: string;
						emailVerified: boolean;
						id: string;
						type: "discord";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						name: string;
						type: "coinbase";
				  }
				| {
						id: string;
						name: string;
						type: "x";
						username: string;
						profileImageUrl?: string;
				  }
				| {
						id: string;
						displayName: string;
						avatarUrl: string;
						unionId?: string;
						type: "tiktok";
				  }
				| {
						avatar?: string;
						id: string;
						metadata: {
							avatar: {
								large?: string;
								medium?: string;
								small?: string;
							};
							personaname?: string;
							profileurl?: string;
							realname?: string;
						};
						type: "steam";
						username?: string;
				  }
				| {
						firstName?: string;
						id: string;
						lastName?: string;
						picture?: string;
						type: "telegram";
						username?: string;
				  }
				| {
						avatar?: string;
						description?: string;
						email?: string;
						id: string;
						type: "twitch";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						type: "line";
						username?: string;
				  }
				| {
						fid: string;
						id: string;
						type: "farcaster";
						walletAddress?: string;
				  }
				| {
						algorithm: string;
						credentialId: string;
						publicKey: string;
						type: "passkey";
				  }
				| {
						email: string;
						id: string;
						type: "email";
				  }
				| {
						id: string;
						pregeneratedIdentifier: string;
						type: "pre_generation";
				  }
				| {
						id: string;
						phone: string;
						type: "phone";
				  }
				| {
						id: string;
						type: "siwe";
						walletAddress: string;
				  }
				| {
						id: string;
						type: "guest";
				  }
				| {
						id: string;
						type: "backend";
				  }
				| {
						identifier: string;
						type: "server";
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_jwt";
						walletAddress?: string;
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_auth_endpoint";
						walletAddress?: string;
				  }
			>;
			/**
			 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
			 */
			smartWalletAddress?: string;
			/**
			 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
			 */
			publicKey?: string;
		};
	};
};

export type CreateServerWalletResponse =
	CreateServerWalletResponses[keyof CreateServerWalletResponses];

export type GetWalletBalanceData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request balance data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * The token contract address. Omit for native token (ETH, MATIC, etc.).
		 */
		tokenAddress?: string;
	};
	url: "/v1/wallets/{address}/balance";
};

export type GetWalletBalanceErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or chain IDs are invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, RPC service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletBalanceResponses = {
	/**
	 * Wallet native balances retrieved successfully. Returns detailed native token balance information for each chain including token metadata and formatted values.
	 */
	200: {
		result: Array<{
			/**
			 * The blockchain network ID
			 */
			chainId: number;
			/**
			 * Number of decimal places for the token
			 */
			decimals: number;
			/**
			 * Human-readable balance formatted with appropriate decimal places
			 */
			displayValue: string;
			/**
			 * The token name (e.g., 'Ether', 'USD Coin')
			 */
			name: string;
			/**
			 * The token symbol (e.g., 'ETH', 'USDC')
			 */
			symbol: string;
			/**
			 * The token contract address. Returns zero address (0x0...0) for native tokens.
			 */
			tokenAddress: string;
			/**
			 * Raw balance value as string in smallest unit (wei for ETH, etc.)
			 */
			value: string;
		}>;
	};
};

export type GetWalletBalanceResponse =
	GetWalletBalanceResponses[keyof GetWalletBalanceResponses];

export type GetWalletTransactionsData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query: {
		/**
		 * Filter by block timestamp (Unix timestamp) greater than or equal to this value
		 */
		filterBlockTimestampGte?: number;
		/**
		 * Filter by block timestamp (Unix timestamp) less than or equal to this value
		 */
		filterBlockTimestampLte?: number;
		/**
		 * Filter by block number greater than or equal to this value
		 */
		filterBlockNumberGte?: number;
		/**
		 * Filter by block number less than or equal to this value
		 */
		filterBlockNumberLte?: number;
		/**
		 * Filter by transaction value (in wei) greater than this value
		 */
		filterValueGt?: string;
		/**
		 * Filter by function selector (4-byte method ID), e.g., '0xa9059cbb' for ERC-20 transfer
		 */
		filterFunctionSelector?: string;
		/**
		 * Current page number
		 */
		page?: number;
		/**
		 * Number of items per page
		 */
		limit?: number;
		/**
		 * Sort order: 'asc' for ascending, 'desc' for descending
		 */
		sortOrder?: "asc" | "desc";
		/**
		 * Chain ID(s) to request transaction data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
	};
	url: "/v1/wallets/{address}/transactions";
};

export type GetWalletTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no transactions available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletTransactionsResponses = {
	/**
	 * Wallet transactions retrieved successfully. Returns transaction data with metadata including pagination information and chain details. Includes decoded function calls when ABI is available.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of wallet transactions.
			 */
			transactions: Array<{
				/**
				 * The hash of the block containing this transaction.
				 */
				blockHash: string;
				/**
				 * The block number containing this transaction.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the transaction occurred.
				 */
				chainId: string;
				/**
				 * Contract address created if this was a contract creation transaction.
				 */
				contractAddress?: string;
				/**
				 * Total gas used by all transactions in this block up to and including this one.
				 */
				cumulativeGasUsed?: number;
				/**
				 * The transaction input data.
				 */
				data: string;
				/**
				 * Decoded transaction data (included when ABI is available).
				 */
				decoded?: {
					/**
					 * Object containing decoded function parameters.
					 */
					inputs: {
						[key: string]: unknown;
					};
					/**
					 * The function name.
					 */
					name: string;
					/**
					 * The function signature.
					 */
					signature: string;
				};
				/**
				 * The effective gas price paid (in wei as string).
				 */
				effectiveGasPrice?: string;
				/**
				 * The address that initiated the transaction.
				 */
				fromAddress: string;
				/**
				 * The function selector (first 4 bytes of the transaction data).
				 */
				functionSelector: string;
				/**
				 * The gas limit for the transaction.
				 */
				gas: number;
				/**
				 * The gas price used for the transaction (in wei as string).
				 */
				gasPrice: string;
				/**
				 * The amount of gas used by the transaction.
				 */
				gasUsed?: number;
				/**
				 * The transaction hash.
				 */
				hash: string;
				/**
				 * Maximum fee per gas (EIP-1559).
				 */
				maxFeePerGas?: string;
				/**
				 * Maximum priority fee per gas (EIP-1559).
				 */
				maxPriorityFeePerGas?: string;
				/**
				 * The transaction nonce.
				 */
				nonce: number;
				/**
				 * The transaction status (1 for success, 0 for failure).
				 */
				status: number;
				/**
				 * The address that received the transaction.
				 */
				toAddress: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
				/**
				 * The transaction type (0=legacy, 1=EIP-2930, 2=EIP-1559).
				 */
				transactionType?: number;
				/**
				 * The value transferred in the transaction (in wei as string).
				 */
				value: string;
			}>;
		};
	};
};

export type GetWalletTransactionsResponse =
	GetWalletTransactionsResponses[keyof GetWalletTransactionsResponses];

export type GetWalletTokensData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request token data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * Token addresses to filter by. If provided, only tokens with these addresses will be returned.
		 */
		tokenAddresses?: Array<string>;
		/**
		 * The number of tokens to return per chain (default: 20, max: 500).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 1, max: 20).
		 */
		page?: number;
	};
	url: "/v1/wallets/{address}/tokens";
};

export type GetWalletTokensErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no tokens available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletTokensResponses = {
	/**
	 * Wallet tokens retrieved successfully. Returns token data with metadata including pagination information and chain details. Includes token balances, metadata, and price information when available.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of wallet tokens.
			 */
			tokens: Array<{
				/**
				 * The token balance as a string
				 */
				balance: string;
				/**
				 * The chain ID of the token
				 */
				chain_id: number;
				/**
				 * The number of decimal places
				 */
				decimals?: number;
				/**
				 * The token name
				 */
				name?: string;
				/**
				 * The token icon URI
				 */
				icon_uri?: string;
				/**
				 * Price data
				 */
				prices?: {
					[key: string]: number;
				};
				/**
				 * Price data for the token
				 */
				price_data?: {
					/**
					 * The circulating supply of the token
					 */
					circulating_supply?: number;
					/**
					 * The market cap of the token in USD
					 */
					market_cap_usd?: number;
					/**
					 * The percentage change of the token in the last 24 hours
					 */
					percent_change_24h?: number;
					/**
					 * The timestamp of the latest price update
					 */
					price_timestamp?: string;
					/**
					 * The price of the token in USD
					 */
					price_usd?: number;
					/**
					 * The total supply of the token
					 */
					total_supply?: number;
					/**
					 * The volume of the token in USD
					 */
					volume_24h_usd?: number;
				};
				/**
				 * The token symbol
				 */
				symbol?: string;
				/**
				 * The contract address of the token
				 */
				token_address: string;
			}>;
		};
	};
};

export type GetWalletTokensResponse =
	GetWalletTokensResponses[keyof GetWalletTokensResponses];

export type GetWalletNftsData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request NFT data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * NFT contract addresses to filter by. If provided, only NFTs with these addresses will be returned.
		 */
		contractAddresses?: Array<string>;
		/**
		 * The number of NFTs to return per chain (default: 20, max: 500).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 1, max: 20).
		 */
		page?: number;
	};
	url: "/v1/wallets/{address}/nfts";
};

export type GetWalletNftsErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no NFTs available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletNftsResponses = {
	/**
	 * Wallet NFTs retrieved successfully. Returns NFT data with metadata including pagination information and chain details. Includes NFT metadata, attributes, and collection information when available.
	 */
	200: {
		result: {
			/**
			 * Array of wallet NFTs.
			 */
			nfts: Array<{
				/**
				 * The animation URL of the NFT
				 */
				animation_url?: string;
				/**
				 * The attributes/traits of the NFT
				 */
				attributes?: Array<{
					/**
					 * The display type
					 */
					display_type?: string;
					/**
					 * The trait type
					 */
					trait_type?: string;
					/**
					 * The trait value
					 */
					value?: string | number;
				}>;
				/**
				 * The chain ID of the NFT
				 */
				chain_id: number;
				/**
				 * Collection information
				 */
				collection?: {
					/**
					 * The collection description
					 */
					description?: string;
					/**
					 * The collection external URL
					 */
					external_url?: string;
					/**
					 * The collection image URL
					 */
					image?: string;
					/**
					 * The collection name
					 */
					name?: string;
				};
				/**
				 * The description of the NFT
				 */
				description?: string;
				/**
				 * The external URL of the NFT
				 */
				external_url?: string;
				/**
				 * The image URL of the NFT
				 */
				image_url?: string;
				/**
				 * Additional metadata for the NFT
				 */
				metadata?: {
					[key: string]: unknown;
				};
				/**
				 * The name of the NFT
				 */
				name?: string;
				/**
				 * The contract address of the NFT collection
				 */
				token_address: string;
				/**
				 * The token ID of the NFT
				 */
				token_id: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetWalletNftsResponse =
	GetWalletNftsResponses[keyof GetWalletNftsResponses];

export type SignMessageData = {
	/**
	 * Request body for signing a message
	 */
	body?: {
		/**
		 * The wallet address or ENS name that will sign the message.
		 */
		from: string;
		/**
		 * The blockchain network identifier where the signing will occur. Common values include: 1 (Ethereum), 137 (Polygon), 56 (BSC).
		 */
		chainId: number;
		/**
		 * The message to be signed. Can be plain text or hexadecimal format (starting with 0x). The format is automatically detected.
		 */
		message: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/sign-message";
};

export type SignMessageErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId is not supported, or the message format is incorrect.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet connectivity issues, signing service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type SignMessageResponses = {
	/**
	 * Message signed successfully. Returns the cryptographic signature that can be used for verification.
	 */
	200: {
		result: {
			/**
			 * The cryptographic signature in hexadecimal format. This can be used for verification and authentication purposes.
			 */
			signature: string;
		};
	};
};

export type SignMessageResponse =
	SignMessageResponses[keyof SignMessageResponses];

export type SignTypedDataData = {
	/**
	 * Request body for signing typed data
	 */
	body?: {
		/**
		 * The wallet address or ENS name that will sign the typed data.
		 */
		from: string;
		/**
		 * The blockchain network identifier for EIP-712 domain separation.
		 */
		chainId: number;
		/**
		 * EIP-712 domain separator containing contract and chain information for signature verification.
		 */
		domain: {
			/**
			 * Chain ID as string for domain separation
			 */
			chainId?: string;
			/**
			 * The domain name (e.g., token name)
			 */
			name?: string;
			/**
			 * Optional salt for additional entropy
			 */
			salt?: string;
			/**
			 * The contract address that will verify this signature
			 */
			verifyingContract?: string;
			/**
			 * Domain version for signature compatibility
			 */
			version?: string;
		};
		/**
		 * The structured data to be signed, matching the defined types schema.
		 */
		message: {
			[key: string]: unknown;
		};
		/**
		 * The primary type name from the types object that defines the main structure being signed.
		 */
		primaryType: string;
		/**
		 * Type definitions for the structured data, following EIP-712 specifications.
		 */
		types: {
			[key: string]: Array<{
				/**
				 * The field name
				 */
				name: string;
				/**
				 * The Solidity type (e.g., 'address', 'uint256')
				 */
				type: string;
			}>;
		};
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/sign-typed-data";
};

export type SignTypedDataErrors = {
	/**
	 * Invalid request parameters. This occurs when the typed data structure is malformed, domain parameters are incorrect, or wallet address format is invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include valid `x-wallet-access-token` headers for accessing the wallet, as well as a x-client-id (frontend) or x-secret-key (backend) for project authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet connectivity issues, signing service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type SignTypedDataResponses = {
	/**
	 * Typed data signed successfully. Returns the EIP-712 compliant signature that can be used for on-chain verification.
	 */
	200: {
		result: {
			/**
			 * The cryptographic signature in hexadecimal format. This can be used for verification and authentication purposes.
			 */
			signature: string;
		};
	};
};

export type SignTypedDataResponse =
	SignTypedDataResponses[keyof SignTypedDataResponses];

export type SendTokensData = {
	/**
	 * Request body for sending tokens to multiple recipients. Supports native tokens, ERC20, ERC721, and ERC1155 transfers based on the provided parameters.
	 */
	body?: {
		/**
		 * The wallet address or ENS name that will send the tokens.
		 */
		from: string;
		/**
		 * The blockchain network identifier where the transfer will be executed.
		 */
		chainId: number;
		/**
		 * Array of recipients and quantities. Maximum 100 recipients per request.
		 */
		recipients: Array<{
			/**
			 * The recipient wallet address or ENS name
			 */
			address: string;
			/**
			 * The amount to send. For native tokens and ERC20: amount in wei/smallest unit. For ERC721: should be '1'. For ERC1155: the number of tokens to transfer.
			 */
			quantity: string;
		}>;
		/**
		 * The token contract address. Omit for native token (ETH, MATIC, etc.) transfers.
		 */
		tokenAddress?: string;
		/**
		 * The token ID for NFT transfers (ERC721/ERC1155). Required for NFT transfers.
		 */
		tokenId?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/send";
};

export type SendTokensErrors = {
	/**
	 * Invalid request parameters. This occurs when token parameters are malformed, insufficient balance, invalid contract data, or unsupported token type.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, gas estimation failures, contract execution errors, or unexpected server errors.
	 */
	500: unknown;
};

export type SendTokensResponses = {
	/**
	 * Tokens sent successfully. Returns transaction IDs for tracking and monitoring.
	 */
	200: {
		result: {
			/**
			 * Array of transaction IDs for the submitted transfers. One ID per recipient.
			 */
			transactionIds: Array<string>;
		};
	};
};

export type SendTokensResponse = SendTokensResponses[keyof SendTokensResponses];

export type ListContractsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * The number of contracts to return (default: 20, max: 100).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 1).
		 */
		page?: number;
	};
	url: "/v1/contracts";
};

export type ListContractsErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type ListContractsResponses = {
	/**
	 * Successfully retrieved list of contracts
	 */
	200: {
		result: {
			/**
			 * Array of contracts imported by the client.
			 */
			contracts: Array<{
				/**
				 * The contract address.
				 */
				address: string;
				/**
				 * The chain ID where the contract is deployed.
				 */
				chainId: string;
				/**
				 * The date when the contract was deployed.
				 */
				deployedAt?: string;
				/**
				 * The contract ID.
				 */
				id?: string;
				/**
				 * The date when the contract was imported to the dashboard.
				 */
				importedAt: string;
				/**
				 * The contract name, if available.
				 */
				name?: string;
				/**
				 * The contract symbol, if available.
				 */
				symbol?: string;
				/**
				 * The contract type (e.g., ERC20, ERC721, etc.).
				 */
				type?: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type ListContractsResponse =
	ListContractsResponses[keyof ListContractsResponses];

export type DeployContractData = {
	/**
	 * Contract deployment specification for raw bytecode deployment.
	 */
	body?: {
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * The wallet address or ENS name that will deploy the contract.
		 */
		from: string;
		/**
		 * The contract bytecode as a hex string.
		 */
		bytecode: string;
		/**
		 * The contract ABI array.
		 */
		abi: Array<unknown>;
		/**
		 * Object containing constructor parameters for the contract deployment (e.g., { param1: 'value1', param2: 123 }).
		 */
		constructorParams?: {
			[key: string]: unknown;
		};
		/**
		 * Optional salt value for deterministic contract deployment.
		 */
		salt?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts";
};

export type DeployContractErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type DeployContractResponses = {
	/**
	 * Contract deployed successfully
	 */
	200: {
		result: {
			/**
			 * The deployed contract address.
			 */
			address: string;
			/**
			 * The chain ID where the contract was deployed.
			 */
			chainId: number;
			/**
			 * The unique identifier for the transaction that deployed the contract. Will not be returned if the contract was already deployed at the predicted address.
			 */
			transactionId?: string;
		};
	};
};

export type DeployContractResponse =
	DeployContractResponses[keyof DeployContractResponses];

export type ReadContractData = {
	body?: {
		/**
		 * Array of contract method calls to execute. Each call specifies a contract address, method signature, and optional parameters.
		 */
		calls: Array<{
			/**
			 * The smart contract address or ENS name.
			 */
			contractAddress: string;
			/**
			 * The contract function signature to call (e.g., 'function approve(address spender, uint256 amount)' or `function balanceOf(address)`). Must start with 'function' followed by the function name and parameters as defined in the contract ABI.
			 */
			method: string;
			/**
			 * Array of parameters to pass to the contract method, in the correct order and format.
			 */
			params?: Array<unknown>;
			/**
			 * Amount of native token to send with the transaction in wei. Required for payable methods.
			 */
			value?: string;
		}>;
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts/read";
};

export type ReadContractErrors = {
	/**
	 * Invalid request parameters. This occurs when the chainId is not supported, contract addresses are invalid, function signatures are malformed, or the calls array is empty.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, RPC node unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type ReadContractResponses = {
	/**
	 * Contract read operations completed successfully. Returns an array of results corresponding to each input call, including both successful and failed operations.
	 */
	200: {
		/**
		 * Array of results corresponding to each contract read call. Results are returned in the same order as the input calls.
		 */
		result: Array<{
			/**
			 * The result of the contract read operation. The type and format depend on the method's return value as defined in the contract ABI.
			 */
			data?: unknown;
			/**
			 * Error message if the contract read operation failed.
			 */
			error?: string;
			/**
			 * Indicates whether the contract read operation was successful.
			 */
			success: boolean;
		}>;
	};
};

export type ReadContractResponse =
	ReadContractResponses[keyof ReadContractResponses];

export type WriteContractData = {
	body?: {
		/**
		 * Array of contract method calls to execute. Each call specifies a contract address, method signature, and optional parameters.
		 */
		calls: Array<{
			/**
			 * The smart contract address or ENS name.
			 */
			contractAddress: string;
			/**
			 * The contract function signature to call (e.g., 'function approve(address spender, uint256 amount)' or `function balanceOf(address)`). Must start with 'function' followed by the function name and parameters as defined in the contract ABI.
			 */
			method: string;
			/**
			 * Array of parameters to pass to the contract method, in the correct order and format.
			 */
			params?: Array<unknown>;
			/**
			 * Amount of native token to send with the transaction in wei. Required for payable methods.
			 */
			value?: string;
		}>;
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * The wallet address or ENS name that will send the transaction.
		 */
		from: string;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts/write";
};

export type WriteContractErrors = {
	/**
	 * Invalid request parameters. This occurs when contract parameters are malformed, method signatures are invalid, insufficient balance, or unsupported contract methods.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Contract not found. The specified contract address does not exist on the given blockchain network or is not accessible.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, gas estimation failures, contract execution errors, or unexpected server errors.
	 */
	500: unknown;
};

export type WriteContractResponses = {
	/**
	 * Contract write operations submitted successfully. Returns transaction IDs for tracking and monitoring.
	 */
	200: {
		result: {
			/**
			 * Array of unique identifiers for the submitted transactions. Use these to track transaction status.
			 */
			transactionIds: Array<string>;
		};
	};
};

export type WriteContractResponse =
	WriteContractResponses[keyof WriteContractResponses];

export type GetContractTransactionsData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier where the contract is deployed.
		 */
		chainId: number;
		/**
		 * The smart contract address or ENS name.
		 */
		address: string;
	};
	query?: {
		/**
		 * Filter by transaction sender address
		 */
		filterFromAddress?: string;
		/**
		 * Filter by transaction recipient address
		 */
		filterToAddress?: string;
		/**
		 * Filter by block timestamp (Unix timestamp) greater than or equal to this value
		 */
		filterBlockTimestampGte?: number;
		/**
		 * Filter by block timestamp (Unix timestamp) less than or equal to this value
		 */
		filterBlockTimestampLte?: number;
		/**
		 * Filter by block number greater than or equal to this value
		 */
		filterBlockNumberGte?: number;
		/**
		 * Filter by block number less than or equal to this value
		 */
		filterBlockNumberLte?: number;
		/**
		 * Filter by transaction value (in wei) greater than this value
		 */
		filterValueGt?: string;
		/**
		 * Filter by function selector (4-byte method ID), e.g., '0xa9059cbb' for ERC-20 transfer
		 */
		filterFunctionSelector?: string;
		/**
		 * Current page number
		 */
		page?: number;
		/**
		 * Number of items per page
		 */
		limit?: number;
		/**
		 * Sort order: 'asc' for ascending, 'desc' for descending
		 */
		sortOrder?: "asc" | "desc";
	};
	url: "/v1/contracts/{chainId}/{address}/transactions";
};

export type GetContractTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when the contract address or chainId format is invalid, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Contract not found or no transactions available for the specified contract address on the given blockchain network.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetContractTransactionsResponses = {
	/**
	 * Contract transactions retrieved successfully. Returns transaction data with metadata including pagination information. Includes decoded function calls when ABI is available.
	 */
	200: {
		result: {
			/**
			 * Array of contract transactions.
			 */
			data: Array<{
				/**
				 * The hash of the block containing this transaction.
				 */
				blockHash: string;
				/**
				 * The block number containing this transaction.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the transaction occurred.
				 */
				chainId: string;
				/**
				 * Contract address created if this was a contract creation transaction.
				 */
				contractAddress?: string;
				/**
				 * Total gas used by all transactions in this block up to and including this one.
				 */
				cumulativeGasUsed?: number;
				/**
				 * The transaction input data.
				 */
				data: string;
				/**
				 * Decoded transaction data (included when ABI is available).
				 */
				decoded?: {
					/**
					 * Object containing decoded function parameters.
					 */
					inputs: {
						[key: string]: unknown;
					};
					/**
					 * The function name.
					 */
					name: string;
					/**
					 * The function signature.
					 */
					signature: string;
				};
				/**
				 * The effective gas price paid (in wei as string).
				 */
				effectiveGasPrice?: string;
				/**
				 * The address that initiated the transaction.
				 */
				fromAddress: string;
				/**
				 * The function selector (first 4 bytes of the transaction data).
				 */
				functionSelector: string;
				/**
				 * The gas limit for the transaction.
				 */
				gas: number;
				/**
				 * The gas price used for the transaction (in wei as string).
				 */
				gasPrice: string;
				/**
				 * The amount of gas used by the transaction.
				 */
				gasUsed?: number;
				/**
				 * The transaction hash.
				 */
				hash: string;
				/**
				 * Maximum fee per gas (EIP-1559).
				 */
				maxFeePerGas?: string;
				/**
				 * Maximum priority fee per gas (EIP-1559).
				 */
				maxPriorityFeePerGas?: string;
				/**
				 * The transaction nonce.
				 */
				nonce: number;
				/**
				 * The transaction status (1 for success, 0 for failure).
				 */
				status: number;
				/**
				 * The address that received the transaction.
				 */
				toAddress: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
				/**
				 * The transaction type (0=legacy, 1=EIP-2930, 2=EIP-1559).
				 */
				transactionType?: number;
				/**
				 * The value transferred in the transaction (in wei as string).
				 */
				value: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetContractTransactionsResponse =
	GetContractTransactionsResponses[keyof GetContractTransactionsResponses];

export type GetContractEventsData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier where the contract is deployed.
		 */
		chainId: number;
		/**
		 * The smart contract address or ENS name.
		 */
		address: string;
	};
	query?: {
		/**
		 * Filter by event signature hash, e.g., '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' for Transfer event
		 */
		signature?: string;
		/**
		 * Filter by event topic 0 (event signature hash)
		 */
		filterTopic0?: string;
		/**
		 * Filter by event topic 1
		 */
		filterTopic1?: string;
		/**
		 * Filter by event topic 2
		 */
		filterTopic2?: string;
		/**
		 * Filter by event topic 3
		 */
		filterTopic3?: string;
		/**
		 * Filter by block timestamp (Unix timestamp) greater than or equal to this value
		 */
		filterBlockTimestampGte?: number;
		/**
		 * Filter by block timestamp (Unix timestamp) less than or equal to this value
		 */
		filterBlockTimestampLte?: number;
		/**
		 * Filter by block number greater than or equal to this value
		 */
		filterBlockNumberGte?: number;
		/**
		 * Filter by block number less than or equal to this value
		 */
		filterBlockNumberLte?: number;
		/**
		 * Current page number
		 */
		page?: number;
		/**
		 * Number of items per page
		 */
		limit?: number;
		/**
		 * Sort order: 'asc' for ascending, 'desc' for descending
		 */
		sortOrder?: "asc" | "desc";
	};
	url: "/v1/contracts/{chainId}/{address}/events";
};

export type GetContractEventsErrors = {
	/**
	 * Invalid request parameters. This occurs when the contract address or chainId format is invalid, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Contract not found or no events available for the specified contract address on the given blockchain network.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetContractEventsResponses = {
	/**
	 * Contract events retrieved successfully. Returns event data with metadata including pagination information. Includes decoded event parameters when ABI is available.
	 */
	200: {
		result: {
			/**
			 * Array of contract events.
			 */
			events: Array<{
				/**
				 * The contract address that emitted the event.
				 */
				address: string;
				/**
				 * The hash of the block containing this event.
				 */
				blockHash: string;
				/**
				 * The block number where the event was emitted.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the event occurred.
				 */
				chainId: string;
				/**
				 * The non-indexed event data as a hex string.
				 */
				data: string;
				/**
				 * Decoded event data (included when ABI is available).
				 */
				decoded?: {
					/**
					 * The event name.
					 */
					name: string;
					/**
					 * Object containing decoded parameters.
					 */
					params: {
						[key: string]: unknown;
					};
					/**
					 * The event signature.
					 */
					signature: string;
				};
				/**
				 * The index of the log within the transaction.
				 */
				logIndex: number;
				/**
				 * Array of indexed event topics (including event signature).
				 */
				topics: Array<string>;
				/**
				 * The hash of the transaction containing this event.
				 */
				transactionHash: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetContractEventsResponse =
	GetContractEventsResponses[keyof GetContractEventsResponses];

export type GetContractMetadataData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier where the contract is deployed.
		 */
		chainId: number;
		/**
		 * The smart contract address or ENS name.
		 */
		address: string;
	};
	query?: never;
	url: "/v1/contracts/{chainId}/{address}/metadata";
};

export type GetContractMetadataErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Contract metadata not found
	 */
	404: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type GetContractMetadataResponses = {
	/**
	 * Contract metadata from the thirdweb contract metadata service.
	 */
	200: {
		result: {
			/**
			 * Compiler information including version.
			 */
			compiler?: {
				/**
				 * Solidity compiler version used to compile the contract.
				 */
				version: string;
			};
			/**
			 * Programming language of the contract (e.g., 'Solidity').
			 */
			language?: string;
			/**
			 * Compilation output including ABI and documentation.
			 */
			output?: {
				/**
				 * Contract ABI (Application Binary Interface) as an array of function/event/error definitions.
				 */
				abi?: Array<unknown>;
				/**
				 * Developer documentation extracted from contract comments.
				 */
				devdoc?: {
					[key: string]: unknown;
				};
				/**
				 * User documentation extracted from contract comments.
				 */
				userdoc?: {
					[key: string]: unknown;
				};
			};
			/**
			 * Compilation settings including optimization and target configuration.
			 */
			settings?: {
				/**
				 * Compilation target mapping source file names to contract names.
				 */
				compilationTarget?: {
					[key: string]: string;
				};
				/**
				 * EVM version target for compilation.
				 */
				evmVersion?: string;
				/**
				 * Library addresses for linking.
				 */
				libraries?: {
					[key: string]: unknown;
				};
				/**
				 * Metadata settings for compilation.
				 */
				metadata?: {
					/**
					 * Hash method used for bytecode metadata.
					 */
					bytecodeHash?: string;
				};
				/**
				 * Optimizer settings used during compilation.
				 */
				optimizer?: {
					/**
					 * Whether optimizer is enabled.
					 */
					enabled?: boolean;
					/**
					 * Number of optimizer runs.
					 */
					runs?: number;
				};
				/**
				 * Import remappings used during compilation.
				 */
				remappings?: Array<string>;
			};
			/**
			 * Metadata format version.
			 */
			version?: number;
		};
	};
};

export type GetContractMetadataResponse =
	GetContractMetadataResponses[keyof GetContractMetadataResponses];

export type GetContractSignaturesData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier where the contract is deployed.
		 */
		chainId: number;
		/**
		 * The smart contract address or ENS name.
		 */
		address: string;
	};
	query?: never;
	url: "/v1/contracts/{chainId}/{address}/signatures";
};

export type GetContractSignaturesErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Contract metadata not found or ABI is not available
	 */
	404: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type GetContractSignaturesResponses = {
	/**
	 * Contract ABI signatures in human-readable format. These signatures can be used directly with contract interaction methods.
	 */
	200: {
		/**
		 * Array of human-readable ABI signatures including functions and events. Each signature is formatted as a string that can be used directly in contract read/write operations or event filtering.
		 */
		result: Array<string>;
	};
};

export type GetContractSignaturesResponse =
	GetContractSignaturesResponses[keyof GetContractSignaturesResponses];

export type GetTransactionByIdData = {
	body?: never;
	path: {
		/**
		 * Unique identifier of the transaction to retrieve.
		 */
		transactionId: string;
	};
	query?: never;
	url: "/v1/transactions/{transactionId}";
};

export type GetTransactionByIdErrors = {
	/**
	 * Invalid request parameters. This occurs when the transaction ID format is invalid or malformed.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Transaction not found. The specified transaction ID does not exist or is not associated with the authenticated client.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, database unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetTransactionByIdResponses = {
	/**
	 * Transaction details retrieved successfully. Returns comprehensive transaction information including status, blockchain details, and execution metadata.
	 */
	200: {
		result: {
			/**
			 * Index within transaction batch
			 */
			batchIndex: number;
			/**
			 * ISO timestamp when transaction was cancelled, if applicable
			 */
			cancelledAt: string;
			/**
			 * Blockchain network identifier as string
			 */
			chainId: string;
			/**
			 * Client identifier that initiated the transaction
			 */
			clientId: string;
			/**
			 * ISO timestamp when transaction was confirmed on-chain
			 */
			confirmedAt: string;
			/**
			 * Block number where transaction was confirmed
			 */
			confirmedAtBlockNumber: string;
			/**
			 * ISO timestamp when transaction was created
			 */
			createdAt: string;
			/**
			 * Additional metadata and enriched transaction information
			 */
			enrichedData?: unknown;
			/**
			 * Error message if transaction failed
			 */
			errorMessage: string;
			/**
			 * Parameters used for transaction execution
			 */
			executionParams?: unknown;
			/**
			 * Result data from transaction execution
			 */
			executionResult?: unknown;
			/**
			 * Sender wallet address
			 */
			from: string;
			/**
			 * Unique transaction identifier
			 */
			id: string;
			/**
			 * On-chain transaction hash once confirmed
			 */
			transactionHash: string;
			/**
			 * Original transaction parameters and data
			 */
			transactionParams?: unknown;
			/**
			 * Transaction status
			 */
			status: "QUEUED" | "SUBMITTED" | "CONFIRMED" | "FAILED";
		};
	};
};

export type GetTransactionByIdResponse =
	GetTransactionByIdResponses[keyof GetTransactionByIdResponses];

export type ListTransactionsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Filter transactions by sender wallet address or ENS name.
		 */
		from?: string;
		/**
		 * Number of transactions to return per page (1-100).
		 */
		limit?: number;
		/**
		 * Page number for pagination, starting from 1.
		 */
		page?: number;
	};
	url: "/v1/transactions";
};

export type ListTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when pagination parameters are out of range or wallet address format is invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, database unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type ListTransactionsResponses = {
	/**
	 * Transactions retrieved successfully. Returns a paginated list of transactions with metadata including creation and confirmation timestamps.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			transactions: Array<{
				/**
				 * Index within transaction batch
				 */
				batchIndex: number;
				/**
				 * ISO timestamp when transaction was cancelled, if applicable
				 */
				cancelledAt: string;
				/**
				 * Blockchain network identifier as string
				 */
				chainId: string;
				/**
				 * Client identifier that initiated the transaction
				 */
				clientId: string;
				/**
				 * ISO timestamp when transaction was confirmed on-chain
				 */
				confirmedAt: string;
				/**
				 * Block number where transaction was confirmed
				 */
				confirmedAtBlockNumber: string;
				/**
				 * ISO timestamp when transaction was created
				 */
				createdAt: string;
				/**
				 * Additional metadata and enriched transaction information
				 */
				enrichedData?: unknown;
				/**
				 * Error message if transaction failed
				 */
				errorMessage: string;
				/**
				 * Parameters used for transaction execution
				 */
				executionParams?: unknown;
				/**
				 * Result data from transaction execution
				 */
				executionResult?: unknown;
				/**
				 * Sender wallet address
				 */
				from: string;
				/**
				 * Unique transaction identifier
				 */
				id: string;
				/**
				 * On-chain transaction hash once confirmed
				 */
				transactionHash: string;
				/**
				 * Original transaction parameters and data
				 */
				transactionParams?: unknown;
				/**
				 * Transaction status
				 */
				status: "QUEUED" | "SUBMITTED" | "CONFIRMED" | "FAILED";
			}>;
		};
	};
};

export type ListTransactionsResponse =
	ListTransactionsResponses[keyof ListTransactionsResponses];

export type SendTransactionsData = {
	/**
	 * Transaction Request
	 * Request object containing an array of encoded blockchain transactions to execute. All transactions must use the same from address and chainId. For contract calls, use /v1/contracts/write. For native token transfers, use /v1/wallets/send.
	 */
	body?: {
		/**
		 * The blockchain network identifier where all transactions will be executed.
		 */
		chainId: number;
		/**
		 * The wallet address or ENS name that will send the transaction.
		 */
		from: string;
		/**
		 * Array of encoded blockchain transactions to execute. All transactions will use the same from address and chainId.
		 */
		transactions: Array<{
			/**
			 * Transaction data in hexadecimal format for contract interactions or custom payloads.
			 */
			data: string;
			/**
			 * The target address or ENS name for the transaction.
			 */
			to: string;
			/**
			 * Amount of native token to send in wei (smallest unit). Use '0' or omit for non-value transactions.
			 */
			value?: string;
		}>;
	};
	path?: never;
	query?: never;
	url: "/v1/transactions";
};

export type SendTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when transaction data is malformed, insufficient balance, or invalid encoded data.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, gas estimation failures, or unexpected server errors.
	 */
	500: unknown;
};

export type SendTransactionsResponses = {
	/**
	 * Encoded transactions submitted successfully. Returns the transaction IDs for tracking and monitoring.
	 */
	200: {
		result: {
			/**
			 * Array of unique identifiers for the submitted transactions. Use these to track transaction status.
			 */
			transactionIds: Array<string>;
		};
	};
};

export type SendTransactionsResponse =
	SendTransactionsResponses[keyof SendTransactionsResponses];

export type CreatePaymentData = {
	/**
	 * Create Product Request
	 * Request to create a product to be purchased. Users can purchase the product via hosted UI (link is returned), a transaction execution referencing the product ID, or embedded widgets with the product ID.
	 */
	body?: {
		/**
		 * The name of the product
		 */
		name: string;
		/**
		 * The description of the product
		 */
		description: string;
		/**
		 * The URL of the product image
		 */
		imageUrl?: string;
		/**
		 * The token to purchase
		 */
		token: {
			/**
			 * The token address to purchase (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
			 */
			address: string;
			/**
			 * The blockchain network where the token is located
			 */
			chainId: number;
			/**
			 * The amount of the token to purchase in wei.
			 */
			amount: string;
		};
		/**
		 * The wallet address or ENS name that will receive the payment for the product
		 */
		recipient: string;
		/**
		 * App specific purchase data for this payment
		 */
		purchaseData?: unknown;
	};
	path?: never;
	query?: never;
	url: "/v1/payments";
};

export type CreatePaymentErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment required. Insufficient wallet balance to complete the purchase.
	 */
	402: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type CreatePaymentResponses = {
	/**
	 * Create Payment Response
	 * Successful payment creation response containing the payment ID and link to purchase the product
	 */
	200: {
		result: {
			/**
			 * The payment ID
			 */
			id: string;
			/**
			 * The link to purchase the product
			 */
			link: string;
		};
	};
};

export type CreatePaymentResponse =
	CreatePaymentResponses[keyof CreatePaymentResponses];

export type GetPaymentHistoryData = {
	body?: never;
	path: {
		id: string;
	};
	query?: never;
	url: "/v1/payments/{id}";
};

export type GetPaymentHistoryErrors = {
	/**
	 * Bad request
	 */
	400: {
		error: string;
	};
	/**
	 * Payment link not found
	 */
	404: {
		error: string;
	};
};

export type GetPaymentHistoryError =
	GetPaymentHistoryErrors[keyof GetPaymentHistoryErrors];

export type GetPaymentHistoryResponses = {
	/**
	 * Payment history retrieved successfully
	 */
	200: {
		/**
		 * List of payments for the client
		 */
		data: Array<{
			id: string;
			blockNumber?: string;
			transactionId?: string;
			onrampId?: string;
			clientId: string;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			sender?: string;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			receiver: string;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			developerFeeRecipient?: string;
			developerFeeBps?: number;
			transactions: Array<{
				chainId: number;
				transactionHash: string;
			}>;
			status: "PENDING" | "COMPLETED" | "FAILED" | "NOT_FOUND";
			type: "buy" | "sell" | "transfer" | "onramp";
			originAmount?: string;
			destinationAmount: string;
			paymentLinkId?: string;
			purchaseData?: unknown;
			originToken?: {
				chainId: number;
				/**
				 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
				 */
				address: string;
				symbol: string;
				name: string;
				decimals: number;
				iconUri?: string;
			};
			destinationToken: {
				chainId: number;
				/**
				 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
				 */
				address: string;
				symbol: string;
				name: string;
				decimals: number;
				iconUri?: string;
			};
			createdAt: string;
		}>;
		meta: {
			/**
			 * Total number of payments
			 */
			totalCount: number;
		};
	};
};

export type GetPaymentHistoryResponse =
	GetPaymentHistoryResponses[keyof GetPaymentHistoryResponses];

export type PaymentsPurchaseData = {
	/**
	 * Purchase Product Request
	 * Request to purchase a product. The system will automatically use your wallet balance to purchase the specified product.
	 */
	body?: {
		/**
		 * The wallet address or ENS name that will purchase the product.
		 */
		from: string;
	};
	path: {
		id: string;
	};
	query?: never;
	url: "/v1/payments/{id}";
};

export type PaymentsPurchaseErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment required. Insufficient wallet balance to complete the purchase.
	 */
	402: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type PaymentsPurchaseResponses = {
	/**
	 * Product purchased successfully. Returns the transaction used for the purchase.
	 */
	200: {
		result: {
			/**
			 * Transaction ID that was executed for your product purchase
			 */
			transactionId: string;
		};
	};
};

export type PaymentsPurchaseResponse =
	PaymentsPurchaseResponses[keyof PaymentsPurchaseResponses];

export type ListTokensData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Number of tokens to return per page (1-100).
		 */
		limit?: number;
		/**
		 * Page number for pagination, starting from 1.
		 */
		page?: number;
		/**
		 * Limit tokens to a specific chain.
		 */
		chainId?: number;
		/**
		 * Get a specific token by contract address
		 */
		tokenAddress?: string;
		/**
		 * Limit tokens to a specific symbol.
		 */
		symbol?: string;
		/**
		 * Limit tokens to a specific name.
		 */
		name?: string;
	};
	url: "/v1/tokens";
};

export type ListTokensErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type ListTokensResponses = {
	/**
	 * Tokens returned successfully.
	 */
	200: {
		pagination: {
			/**
			 * Whether there are more items available
			 */
			hasMore?: boolean;
			/**
			 * Number of items per page
			 */
			limit?: number;
			/**
			 * Current page number
			 */
			page?: number;
			/**
			 * Total number of items available
			 */
			totalCount?: number;
		};
		tokens: Array<{
			/**
			 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
			 */
			chainId: number;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			address: string;
			decimals: number;
			symbol: string;
			iconUri?: string;
			/**
			 * Token price in different FIAT currencies.
			 */
			prices: {
				[key: string]: number;
			};
		}>;
	};
};

export type ListTokensResponse = ListTokensResponses[keyof ListTokensResponses];

export type CreateTokenData = {
	/**
	 * Request schema for creating a new ERC20 token
	 */
	body?: {
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * Token name
		 */
		name: string;
		/**
		 * Token symbol
		 */
		symbol: string;
		/**
		 * Token description
		 */
		description: string;
		/**
		 * Token image URL
		 */
		imageUrl: string;
		/**
		 * Wallet address or ENS that will deploy the token.
		 */
		from: string;
		/**
		 * The token owner address, if different from `from`.
		 */
		owner?: string;
		/**
		 * A salt to deterministically generate the token address.
		 */
		salt?: string;
		/**
		 * The maximum token supply.
		 */
		maxSupply?: number;
		/**
		 * Setup this token for a sale.
		 */
		sale?: {
			type?: "pool";
			/**
			 * The initial token price in wei. This price is in the currency specified by `currency` (or the native token if not specified).
			 */
			startingPrice: string;
			/**
			 * The number of tokens to allocate to the sale.
			 */
			amount: number;
			/**
			 * The bps fee on the token pool.
			 */
			developerFeeBps?: number;
			/**
			 * The address to send the developer fee to. Defaults to the token owner.
			 */
			developerFeeRecipient?: string;
			/**
			 * The currency to price this token sale in. Defaults to the native token.
			 */
			currency?: string;
		};
	};
	path?: never;
	query?: never;
	url: "/v1/tokens";
};

export type CreateTokenErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment required. Insufficient wallet balance to deploy the contract.
	 */
	402: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type CreateTokenResponses = {
	/**
	 * The token is being deployed. Returns the predicted token address.
	 */
	202: {
		/**
		 * The in-progress deployment transaction ID.
		 */
		transactionId: string;
		/**
		 * The address the token was deployed at
		 */
		address: string;
	};
};

export type CreateTokenResponse =
	CreateTokenResponses[keyof CreateTokenResponses];

export type GetTokenOwnersData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query?: {
		/**
		 * Number of owners to return per page (1-100).
		 */
		limit?: number;
		/**
		 * Page number for pagination, starting from 1.
		 */
		page?: number;
	};
	url: "/v1/tokens/{chainId}/{address}/owners";
};

export type GetTokenOwnersErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Token not found or no owners available.
	 */
	404: unknown;
	/**
	 * Internal server error.
	 */
	500: unknown;
};

export type GetTokenOwnersResponses = {
	/**
	 * Token owners retrieved successfully. Returns owners with pagination information.
	 */
	200: {
		result: {
			/**
			 * Array of token owners with amounts.
			 */
			owners: Array<{
				/**
				 * Owner wallet address
				 */
				address: string;
				/**
				 * Token amount owned as a string
				 */
				amount: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetTokenOwnersResponse =
	GetTokenOwnersResponses[keyof GetTokenOwnersResponses];

export type BridgeSwapData = {
	/**
	 * Swap Token Request
	 * Request to swap tokens using the optimal route available. You can specify a tokenIn amount (if exact='input') or tokenOut amount (if exact='output'), but not both. The corresponding output or input amount will be returned as the quote.
	 */
	body?: {
		/**
		 * Whether to swap the exact input or output amount
		 */
		exact?: "input" | "output";
		tokenIn: {
			/**
			 * The input token address to swap (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
			 */
			address: string;
			/**
			 * The blockchain network where the token is located
			 */
			chainId: number;
			/**
			 * The amount of the input token to swap in wei.
			 */
			amount?: string;
			/**
			 * The maximum amount of the input token to swap in wei.
			 */
			maxAmount?: string;
		};
		tokenOut: {
			/**
			 * The output token address to swap (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
			 */
			address: string;
			/**
			 * The blockchain network where the token is located
			 */
			chainId: number;
			/**
			 * The amount of the output token to receive in wei.
			 */
			amount?: string;
			/**
			 * The minimum amount of the output token to receive in wei.
			 */
			minAmount?: string;
		};
		/**
		 * The wallet address or ENS name that will execute the swap.
		 */
		from: string;
	};
	path?: never;
	query?: never;
	url: "/v1/bridge/swap";
};

export type BridgeSwapErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment required. Insufficient wallet balance to complete the purchase.
	 */
	402: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type BridgeSwapResponses = {
	/**
	 * Swap Token Response
	 * Successful token swap response containing executed transaction ID
	 */
	200: {
		result: {
			/**
			 * Payment transaction ID that was executed
			 */
			transactionId: string;
		};
	};
};

export type BridgeSwapResponse = BridgeSwapResponses[keyof BridgeSwapResponses];

export type ChatData = {
	/**
	 * Chat Request
	 * Chat request
	 */
	body?: {
		/**
		 * Natural language query for the AI assistant
		 */
		messages: Array<{
			role: "user" | "assistant" | "system" | "tool";
			content:
				| string
				| Array<
						| {
								type: "image";
								image_url?: string;
								b64?: string;
						  }
						| {
								type: "text";
								text: string;
						  }
						| {
								type: "transaction";
								chain_id: number;
								transaction_hash: string;
						  }
				  >;
		}>;
		/**
		 * Context for the AI assistant
		 */
		context?: {
			/**
			 * Optional wallet address that will execute transactions
			 */
			from?: string;
			/**
			 * Optional chain IDs for context
			 */
			chain_ids?: Array<number>;
			/**
			 * Optional session ID for conversation continuity. If not provided, a new session will be created
			 */
			session_id?: string;
			/**
			 * Whether to automatically execute transactions. If not provided, the default is false
			 */
			auto_execute_transactions?: boolean;
		};
		/**
		 * Enable server streaming of the AI response
		 */
		stream?: boolean;
	};
	path?: never;
	query?: never;
	url: "/ai/chat";
};

export type ChatResponses = {
	/**
	 * Chat Response
	 * Chat response
	 */
	200: {
		/**
		 * The AI assistant's response
		 */
		message: string;
		actions: Array<
			| {
					session_id: string;
					request_id: string;
					source?: string;
					type: "sign_transaction";
					data: {
						chain_id: number;
						function?: string;
						to: string;
						value: string;
						data: string;
					};
			  }
			| {
					session_id: string;
					request_id: string;
					source?: string;
					type: "sign_swap";
					data: {
						transaction: {
							chain_id: number;
							function?: string;
							to: string;
							value: string;
							data: string;
						};
						action: string;
						intent: {
							origin_chain_id: number;
							origin_token_address: string;
							destination_chain_id: number;
							destination_token_address: string;
							amount: string;
							sender: string;
							receiver: string;
							maxSteps: number;
						};
						from_token: {
							address: string;
							chain_id: number;
							amount: string;
							symbol: string;
							decimals: number;
							price: number;
						};
						to_token: {
							address: string;
							chain_id: number;
							amount: string;
							symbol: string;
							decimals: number;
							price: number;
						};
					};
			  }
			| {
					session_id: string;
					request_id: string;
					source?: string;
					type: "monitor_transaction";
					data: {
						transaction_id: string;
					};
			  }
		>;
		session_id: string;
		request_id: string;
	};
};

export type ChatResponse = ChatResponses[keyof ChatResponses];

export type McpServerData = {
	body?: unknown;
	path?: never;
	query?: never;
	url: "/mcp";
};

export type McpServerResponses = {
	/**
	 * MCP response
	 */
	200: unknown;
};

export type LlmsTxtData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/llms.txt";
};

export type LlmsTxtResponses = {
	/**
	 * LLMs.txt
	 */
	200: string;
};

export type LlmsTxtResponse = LlmsTxtResponses[keyof LlmsTxtResponses];

export type ClientOptions = {
	baseUrl: "https://api.thirdweb.com" | (string & {});
};
