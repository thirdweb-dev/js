// This file is auto-generated by @hey-api/openapi-ts

export type ListContractsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Whether to include the contract ABI (Application Binary Interface) for each contract. When true, fetches the ABI from the thirdweb contract service and returns it in an optional 'abi' array within each contract.
		 */
		includeAbi?: string;
		/**
		 * Whether to include contract metadata from the thirdweb contract metadata service. When true, fetches additional metadata for each contract and returns it in an optional 'metadata' object within each contract.
		 */
		includeMetadata?: string;
		/**
		 * The number of contracts to return (default: 20, max: 100).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 1).
		 */
		page?: number;
	};
	url: "/v1/contracts";
};

export type ListContractsErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type ListContractsResponses = {
	/**
	 * Successfully retrieved list of contracts
	 */
	200: {
		result: {
			/**
			 * Array of contracts imported by the client.
			 */
			contracts: Array<{
				/**
				 * The contract ABI (Application Binary Interface) as an array of objects. Contains function definitions, event signatures, constructor parameters, error definitions, and other contract interface specifications. Only present when includeAbi=true.
				 */
				abi?: Array<{
					[key: string]: unknown;
				}>;
				/**
				 * The contract address.
				 */
				address: string;
				/**
				 * The chain ID where the contract is deployed.
				 */
				chainId: string;
				/**
				 * The date when the contract was deployed.
				 */
				deployedAt?: string;
				/**
				 * The contract ID.
				 */
				id?: string;
				/**
				 * The date when the contract was imported to the dashboard.
				 */
				importedAt: string;
				/**
				 * Additional contract metadata from the thirdweb contract metadata service. Only present when includeMetadata=true. Contains compilation details, ABI information, and Solidity metadata.
				 */
				metadata?: {
					/**
					 * The chain ID where the contract is deployed.
					 */
					chainId: number;
					/**
					 * Array of compilation target paths.
					 */
					compilationTarget?: Array<string>;
					/**
					 * The contract address.
					 */
					contractAddress: string;
					/**
					 * The implementation address for proxy contracts.
					 */
					implementationAddress?: string;
					/**
					 * Whether the ABI is a composite of multiple contracts.
					 */
					isCompositeAbi?: boolean;
					/**
					 * Whether the ABI is partial or complete.
					 */
					isPartialAbi?: boolean;
					/**
					 * Solidity metadata object as defined in the Solidity documentation. Contains compiler settings, sources, and other compilation metadata.
					 */
					metadata?: {
						[key: string]: unknown;
					};
					/**
					 * The strategy used to retrieve the metadata.
					 */
					strategy?: string;
				};
				/**
				 * The contract name, if available.
				 */
				name?: string;
				/**
				 * The contract symbol, if available.
				 */
				symbol?: string;
				/**
				 * The contract type (e.g., ERC20, ERC721, etc.).
				 */
				type?: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit: number;
				/**
				 * Current page number
				 */
				page: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type ListContractsResponse =
	ListContractsResponses[keyof ListContractsResponses];

export type DeployContractData = {
	body?: {
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * Object containing constructor parameters for the contract deployment (e.g., { param1: 'value1', param2: 123 }).
		 */
		constructorParams?: {
			[key: string]: unknown;
		};
		/**
		 * The URL to the contract source from thirdweb.com (e.g., https://thirdweb.com/thirdweb.eth/TokenERC20). Version suffixes will be automatically stripped.
		 */
		contractUrl: string;
		/**
		 * The wallet address that will deploy the contract.
		 */
		from: string;
		/**
		 * Optional salt value for deterministic contract deployment.
		 */
		salt?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts";
};

export type DeployContractErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type DeployContractResponses = {
	/**
	 * Contract deployed successfully
	 */
	200: {
		result: {
			/**
			 * The deployed contract address.
			 */
			address: string;
			/**
			 * The chain ID where the contract was deployed.
			 */
			chainId: number;
			/**
			 * The unique identifier for the transaction that deployed the contract. Will not be returned if the contract was already deployed at the predicted address.
			 */
			transactionId?: string;
		};
	};
};

export type DeployContractResponse =
	DeployContractResponses[keyof DeployContractResponses];

export type ReadContractData = {
	body?: {
		/**
		 * Array of contract method calls to execute. Each call specifies a contract address, method signature, and optional parameters.
		 */
		calls: Array<{
			/**
			 * The smart contract address. Must be a valid Ethereum-compatible address (42 characters, starting with 0x).
			 */
			contractAddress: string;
			/**
			 * The contract function signature to call (e.g., 'function approve(address spender, uint256 amount)' or `function balanceOf(address)`). Must start with 'function' followed by the function name and parameters as defined in the contract ABI.
			 */
			method: string;
			/**
			 * Array of parameters to pass to the contract method, in the correct order and format.
			 */
			params?: Array<unknown>;
			/**
			 * Amount of native token to send with the transaction in wei. Required for payable methods.
			 */
			value?: string;
		}>;
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts/read";
};

export type ReadContractErrors = {
	/**
	 * Invalid request parameters. This occurs when the chainId is not supported, contract addresses are invalid, function signatures are malformed, or the calls array is empty.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, RPC node unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type ReadContractResponses = {
	/**
	 * Contract read operations completed successfully. Returns an array of results corresponding to each input call, including both successful and failed operations.
	 */
	200: {
		/**
		 * Array of results corresponding to each contract read call. Results are returned in the same order as the input calls.
		 */
		result: Array<{
			/**
			 * The result of the contract read operation. The type and format depend on the method's return value as defined in the contract ABI.
			 */
			data?: unknown;
			/**
			 * Error message if the contract read operation failed.
			 */
			error?: string;
			/**
			 * Indicates whether the contract read operation was successful.
			 */
			success: boolean;
		}>;
	};
};

export type ReadContractResponse =
	ReadContractResponses[keyof ReadContractResponses];

export type GetContractTransactionsData = {
	body?: never;
	path: {
		/**
		 * The smart contract address. Must be a valid Ethereum-compatible address (42 characters, starting with 0x).
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request transaction data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * Whether to enable ABI decoding of transaction data. When true, returns decoded function calls if ABI is available.
		 */
		decode?: boolean;
		/**
		 * The number of transactions to return per chain (default: 20, max: 500).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 0, max: 20).
		 */
		page?: number;
		/**
		 * Sort order - ascending or descending (default: desc).
		 */
		sortOrder?: "asc" | "desc";
		/**
		 * Start time for filtering transactions (Unix timestamp). Default is 3 months ago.
		 */
		startTime?: number;
	};
	url: "/v1/contracts/{address}/transactions";
};

export type GetContractTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when the contract address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Contract not found or no transactions available for the specified contract address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetContractTransactionsResponses = {
	/**
	 * Contract transactions retrieved successfully. Returns transaction data with metadata including pagination information and chain details. When decode=true, includes decoded function calls if ABI is available.
	 */
	200: {
		result: {
			/**
			 * Array of contract transactions.
			 */
			data: Array<{
				/**
				 * The hash of the block containing this transaction.
				 */
				blockHash: string;
				/**
				 * The block number containing this transaction.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the transaction occurred.
				 */
				chainId: string;
				/**
				 * Contract address created if this was a contract creation transaction.
				 */
				contractAddress?: string;
				/**
				 * Total gas used by all transactions in this block up to and including this one.
				 */
				cumulativeGasUsed?: number;
				/**
				 * The transaction input data.
				 */
				data: string;
				/**
				 * Decoded transaction data (only present when decode=true and ABI is available).
				 */
				decoded?: {
					/**
					 * Object containing decoded function parameters.
					 */
					inputs: {
						[key: string]: unknown;
					};
					/**
					 * The function name.
					 */
					name: string;
					/**
					 * The function signature.
					 */
					signature: string;
				};
				/**
				 * The effective gas price paid (in wei as string).
				 */
				effectiveGasPrice?: string;
				/**
				 * The address that initiated the transaction.
				 */
				fromAddress: string;
				/**
				 * The function selector (first 4 bytes of the transaction data).
				 */
				functionSelector: string;
				/**
				 * The gas limit for the transaction.
				 */
				gas: number;
				/**
				 * The gas price used for the transaction (in wei as string).
				 */
				gasPrice: string;
				/**
				 * The amount of gas used by the transaction.
				 */
				gasUsed?: number;
				/**
				 * The transaction hash.
				 */
				hash: string;
				/**
				 * Maximum fee per gas (EIP-1559).
				 */
				maxFeePerGas?: string;
				/**
				 * Maximum priority fee per gas (EIP-1559).
				 */
				maxPriorityFeePerGas?: string;
				/**
				 * The transaction nonce.
				 */
				nonce: number;
				/**
				 * The transaction status (1 for success, 0 for failure).
				 */
				status: number;
				/**
				 * The address that received the transaction.
				 */
				toAddress: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
				/**
				 * The transaction type (0=legacy, 1=EIP-2930, 2=EIP-1559).
				 */
				transactionType?: number;
				/**
				 * The value transferred in the transaction (in wei as string).
				 */
				value: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit: number;
				/**
				 * Current page number
				 */
				page: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetContractTransactionsResponse =
	GetContractTransactionsResponses[keyof GetContractTransactionsResponses];

export type GetContractEventsData = {
	body?: never;
	path: {
		/**
		 * The smart contract address. Must be a valid Ethereum-compatible address (42 characters, starting with 0x).
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request event data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * Whether to enable ABI decoding of event data. When true, returns decoded event parameters if ABI is available.
		 */
		decode?: boolean;
		/**
		 * Maximum number of events to return per chain. Must be between 1 and 500. Default is 20.
		 */
		limit?: number;
		/**
		 * Page number for pagination (0-based). Must be between 0 and 20. Default is 0.
		 */
		page?: number;
		/**
		 * Sort order for the results. Always sorts by block_number. 'desc' for newest first, 'asc' for oldest first. Default is 'desc'.
		 */
		sortOrder?: "asc" | "desc";
		/**
		 * Start time for filtering events (Unix timestamp). Default is 3 months ago.
		 */
		startTime?: number;
	};
	url: "/v1/contracts/{address}/events";
};

export type GetContractEventsErrors = {
	/**
	 * Invalid request parameters. This occurs when the contract address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Contract not found or no events available for the specified contract address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetContractEventsResponses = {
	/**
	 * Contract events retrieved successfully. Returns event data with metadata including pagination information and chain details. When decode=true, includes decoded event parameters if ABI is available.
	 */
	200: {
		result: {
			/**
			 * Array of contract events.
			 */
			events: Array<{
				/**
				 * The contract address that emitted the event.
				 */
				address: string;
				/**
				 * The hash of the block containing this event.
				 */
				blockHash: string;
				/**
				 * The block number where the event was emitted.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the event occurred.
				 */
				chainId: string;
				/**
				 * The non-indexed event data as a hex string.
				 */
				data: string;
				/**
				 * Decoded event data (only present when decode=true and ABI is available).
				 */
				decoded?: {
					/**
					 * The event name.
					 */
					name: string;
					/**
					 * Object containing decoded parameters.
					 */
					params: {
						[key: string]: unknown;
					};
					/**
					 * The event signature.
					 */
					signature: string;
				};
				/**
				 * The index of the log within the transaction.
				 */
				logIndex: number;
				/**
				 * Array of indexed event topics (including event signature).
				 */
				topics: Array<string>;
				/**
				 * The hash of the transaction containing this event.
				 */
				transactionHash: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit: number;
				/**
				 * Current page number
				 */
				page: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetContractEventsResponse =
	GetContractEventsResponses[keyof GetContractEventsResponses];

export type WriteContractData = {
	body?: {
		/**
		 * Array of contract method calls to execute. Each call specifies a contract address, method signature, and optional parameters.
		 */
		calls: Array<{
			/**
			 * The smart contract address. Must be a valid Ethereum-compatible address (42 characters, starting with 0x).
			 */
			contractAddress: string;
			/**
			 * The contract function signature to call (e.g., 'function approve(address spender, uint256 amount)' or `function balanceOf(address)`). Must start with 'function' followed by the function name and parameters as defined in the contract ABI.
			 */
			method: string;
			/**
			 * Array of parameters to pass to the contract method, in the correct order and format.
			 */
			params?: Array<unknown>;
			/**
			 * Amount of native token to send with the transaction in wei. Required for payable methods.
			 */
			value?: string;
		}>;
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * The wallet address that will send the transaction.
		 */
		from: string;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts/write";
};

export type WriteContractErrors = {
	/**
	 * Invalid request parameters. This occurs when contract parameters are malformed, method signatures are invalid, insufficient balance, or unsupported contract methods.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Contract not found. The specified contract address does not exist on the given blockchain network or is not accessible.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, gas estimation failures, contract execution errors, or unexpected server errors.
	 */
	500: unknown;
};

export type WriteContractResponses = {
	/**
	 * Contract write operations submitted successfully. Returns transaction IDs for tracking and monitoring.
	 */
	200: {
		result: {
			/**
			 * Array of unique identifiers for the submitted transactions. Use these to track transaction status.
			 */
			transactionIds: Array<string>;
		};
	};
};

export type WriteContractResponse =
	WriteContractResponses[keyof WriteContractResponses];

export type ListWalletsData = {
	body?: never;
	path?: never;
	query?: {
		limit?: number;
		page?: number;
		/**
		 * Type of wallet to fetch, default is user
		 */
		type?: "user" | "server";
	};
	url: "/v1/wallets";
};

export type ListWalletsErrors = {
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type ListWalletsResponses = {
	/**
	 * Returns a list of wallet addresses, smart wallet addresses, and auth details.
	 */
	200: {
		result: {
			/**
			 * Pagination information
			 */
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit: number;
				/**
				 * Current page number
				 */
				page: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of user or server wallets
			 */
			wallets: Array<{
				/**
				 * The EOA (Externally Owned Account) address of the wallet. This is the traditional wallet address.
				 */
				address: string;
				/**
				 * The date and time the wallet was created
				 */
				createdAt: string;
				/**
				 * The profiles linked to the wallet, can be email, phone, google etc, or backend for developer created wallets
				 */
				profiles: Array<
					| {
							email: string;
							emailVerified: boolean;
							familyName?: string;
							givenName?: string;
							hd: string;
							id: string;
							locale: string;
							name?: string;
							picture: string;
							type: "google";
					  }
					| {
							email?: string;
							firstName?: string;
							id: string;
							lastName?: string;
							name?: string;
							picture?: string;
							type: "facebook";
					  }
					| {
							email?: string;
							emailVerified: boolean;
							id: string;
							isPrivateEmail: boolean;
							type: "apple";
					  }
					| {
							avatar?: string;
							id: string;
							name?: string;
							type: "github";
							username: string;
					  }
					| {
							avatar: string;
							email?: string;
							emailVerified: boolean;
							id: string;
							type: "discord";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							name: string;
							type: "coinbase";
					  }
					| {
							id: string;
							name: string;
							type: "x";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							metadata: {
								avatar: {
									large?: string;
									medium?: string;
									small?: string;
								};
								personaname?: string;
								profileurl?: string;
								realname?: string;
							};
							type: "steam";
							username?: string;
					  }
					| {
							firstName?: string;
							id: string;
							lastName?: string;
							picture?: string;
							type: "telegram";
							username?: string;
					  }
					| {
							avatar?: string;
							description?: string;
							email?: string;
							id: string;
							type: "twitch";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							type: "line";
							username?: string;
					  }
					| {
							fid: string;
							id: string;
							type: "farcaster";
							walletAddress?: string;
					  }
					| {
							algorithm: string;
							credentialId: string;
							publicKey: string;
							type: "passkey";
					  }
					| {
							email: string;
							id: string;
							type: "email";
					  }
					| {
							id: string;
							pregeneratedIdentifier: string;
							type: "pre_generation";
					  }
					| {
							id: string;
							phone: string;
							type: "phone";
					  }
					| {
							id: string;
							type: "siwe";
							walletAddress: string;
					  }
					| {
							id: string;
							type: "guest";
					  }
					| {
							id: string;
							type: "backend";
					  }
					| {
							identifier: string;
							type: "server";
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_jwt";
							walletAddress?: string;
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_auth_endpoint";
							walletAddress?: string;
					  }
				>;
				/**
				 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced account features.
				 */
				smartWalletAddress?: string;
			}>;
		};
	};
};

export type ListWalletsResponse =
	ListWalletsResponses[keyof ListWalletsResponses];

export type CreateWalletData = {
	body?: {
		/**
		 * Unique identifier for wallet creation or retrieval. Can be user ID, email, or any unique string. The same identifier will always return the same wallet.
		 */
		identifier: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets";
};

export type CreateWalletErrors = {
	/**
	 * Invalid request parameters. This occurs when the identifier format is invalid or required parameters are missing.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet service unavailability, smart account deployment issues, or unexpected server errors.
	 */
	500: unknown;
};

export type CreateWalletResponses = {
	/**
	 * Wallet created or connected successfully. Returns wallet addresses for subsequent operations.
	 */
	200: {
		result: {
			/**
			 * The EOA (Externally Owned Account) address of the wallet. This is the traditional wallet address.
			 */
			address: string;
			/**
			 * The date and time the wallet was created
			 */
			createdAt: string;
			/**
			 * The profiles linked to the wallet, can be email, phone, google etc, or backend for developer created wallets
			 */
			profiles: Array<
				| {
						email: string;
						emailVerified: boolean;
						familyName?: string;
						givenName?: string;
						hd: string;
						id: string;
						locale: string;
						name?: string;
						picture: string;
						type: "google";
				  }
				| {
						email?: string;
						firstName?: string;
						id: string;
						lastName?: string;
						name?: string;
						picture?: string;
						type: "facebook";
				  }
				| {
						email?: string;
						emailVerified: boolean;
						id: string;
						isPrivateEmail: boolean;
						type: "apple";
				  }
				| {
						avatar?: string;
						id: string;
						name?: string;
						type: "github";
						username: string;
				  }
				| {
						avatar: string;
						email?: string;
						emailVerified: boolean;
						id: string;
						type: "discord";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						name: string;
						type: "coinbase";
				  }
				| {
						id: string;
						name: string;
						type: "x";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						metadata: {
							avatar: {
								large?: string;
								medium?: string;
								small?: string;
							};
							personaname?: string;
							profileurl?: string;
							realname?: string;
						};
						type: "steam";
						username?: string;
				  }
				| {
						firstName?: string;
						id: string;
						lastName?: string;
						picture?: string;
						type: "telegram";
						username?: string;
				  }
				| {
						avatar?: string;
						description?: string;
						email?: string;
						id: string;
						type: "twitch";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						type: "line";
						username?: string;
				  }
				| {
						fid: string;
						id: string;
						type: "farcaster";
						walletAddress?: string;
				  }
				| {
						algorithm: string;
						credentialId: string;
						publicKey: string;
						type: "passkey";
				  }
				| {
						email: string;
						id: string;
						type: "email";
				  }
				| {
						id: string;
						pregeneratedIdentifier: string;
						type: "pre_generation";
				  }
				| {
						id: string;
						phone: string;
						type: "phone";
				  }
				| {
						id: string;
						type: "siwe";
						walletAddress: string;
				  }
				| {
						id: string;
						type: "guest";
				  }
				| {
						id: string;
						type: "backend";
				  }
				| {
						identifier: string;
						type: "server";
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_jwt";
						walletAddress?: string;
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_auth_endpoint";
						walletAddress?: string;
				  }
			>;
			/**
			 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced account features.
			 */
			smartWalletAddress?: string;
		};
	};
};

export type CreateWalletResponse =
	CreateWalletResponses[keyof CreateWalletResponses];

export type GetWalletBalanceData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address, which is a 40-character hexadecimal string (0x prefixed) representing an account on the Ethereum blockchain.
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request balance data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
	};
	url: "/v1/wallets/{address}/balance";
};

export type GetWalletBalanceErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or chain IDs are invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, RPC service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletBalanceResponses = {
	/**
	 * Wallet native balances retrieved successfully. Returns detailed native token balance information for each chain including token metadata and formatted values.
	 */
	200: {
		result: Array<{
			/**
			 * The blockchain network ID
			 */
			chainId: number;
			/**
			 * Number of decimal places for the token
			 */
			decimals: number;
			/**
			 * Human-readable balance formatted with appropriate decimal places
			 */
			displayValue: string;
			/**
			 * The token name (e.g., 'Ether', 'USD Coin')
			 */
			name: string;
			/**
			 * The token symbol (e.g., 'ETH', 'USDC')
			 */
			symbol: string;
			/**
			 * The token contract address. Returns zero address (0x0...0) for native tokens.
			 */
			tokenAddress: string;
			/**
			 * Raw balance value as string in smallest unit (wei for ETH, etc.)
			 */
			value: string;
		}>;
	};
};

export type GetWalletBalanceResponse =
	GetWalletBalanceResponses[keyof GetWalletBalanceResponses];

export type GetWalletTransactionsData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address, which is a 40-character hexadecimal string (0x prefixed) representing an account on the Ethereum blockchain.
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request transaction data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * Whether to enable ABI decoding of transaction data. When true, returns decoded function calls if ABI is available.
		 */
		decode?: boolean;
		/**
		 * The number of transactions to return per chain (default: 20, max: 500).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 0, max: 20).
		 */
		page?: number;
		/**
		 * Sort order - ascending or descending (default: desc).
		 */
		sortOrder?: "asc" | "desc";
		/**
		 * Start time for filtering transactions (Unix timestamp). Default is 3 months ago.
		 */
		startTime?: number;
	};
	url: "/v1/wallets/{address}/transactions";
};

export type GetWalletTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no transactions available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletTransactionsResponses = {
	/**
	 * Wallet transactions retrieved successfully. Returns transaction data with metadata including pagination information and chain details. When decode=true, includes decoded function calls if ABI is available.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit: number;
				/**
				 * Current page number
				 */
				page: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of wallet transactions.
			 */
			transactions: Array<{
				/**
				 * The hash of the block containing this transaction.
				 */
				blockHash: string;
				/**
				 * The block number containing this transaction.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the transaction occurred.
				 */
				chainId: string;
				/**
				 * Contract address created if this was a contract creation transaction.
				 */
				contractAddress?: string;
				/**
				 * Total gas used by all transactions in this block up to and including this one.
				 */
				cumulativeGasUsed?: number;
				/**
				 * The transaction input data.
				 */
				data: string;
				/**
				 * Decoded transaction data (only present when decode=true and ABI is available).
				 */
				decoded?: {
					/**
					 * Object containing decoded function parameters.
					 */
					inputs: {
						[key: string]: unknown;
					};
					/**
					 * The function name.
					 */
					name: string;
					/**
					 * The function signature.
					 */
					signature: string;
				};
				/**
				 * The effective gas price paid (in wei as string).
				 */
				effectiveGasPrice?: string;
				/**
				 * The address that initiated the transaction.
				 */
				fromAddress: string;
				/**
				 * The function selector (first 4 bytes of the transaction data).
				 */
				functionSelector: string;
				/**
				 * The gas limit for the transaction.
				 */
				gas: number;
				/**
				 * The gas price used for the transaction (in wei as string).
				 */
				gasPrice: string;
				/**
				 * The amount of gas used by the transaction.
				 */
				gasUsed?: number;
				/**
				 * The transaction hash.
				 */
				hash: string;
				/**
				 * Maximum fee per gas (EIP-1559).
				 */
				maxFeePerGas?: string;
				/**
				 * Maximum priority fee per gas (EIP-1559).
				 */
				maxPriorityFeePerGas?: string;
				/**
				 * The transaction nonce.
				 */
				nonce: number;
				/**
				 * The transaction status (1 for success, 0 for failure).
				 */
				status: number;
				/**
				 * The address that received the transaction.
				 */
				toAddress: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
				/**
				 * The transaction type (0=legacy, 1=EIP-2930, 2=EIP-1559).
				 */
				transactionType?: number;
				/**
				 * The value transferred in the transaction (in wei as string).
				 */
				value: string;
			}>;
		};
	};
};

export type GetWalletTransactionsResponse =
	GetWalletTransactionsResponses[keyof GetWalletTransactionsResponses];

export type GetWalletTokensData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address, which is a 40-character hexadecimal string (0x prefixed) representing an account on the Ethereum blockchain.
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request token data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * The number of tokens to return per chain (default: 20, max: 500).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 0, max: 20).
		 */
		page?: number;
	};
	url: "/v1/wallets/{address}/tokens";
};

export type GetWalletTokensErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no tokens available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletTokensResponses = {
	/**
	 * Wallet tokens retrieved successfully. Returns token data with metadata including pagination information and chain details. Includes token balances, metadata, and price information when available.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit: number;
				/**
				 * Current page number
				 */
				page: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of wallet tokens.
			 */
			tokens: Array<{
				/**
				 * The token balance as a string
				 */
				balance: string;
				/**
				 * The chain ID of the token
				 */
				chain_id: number;
				/**
				 * The number of decimal places
				 */
				decimals?: number;
				/**
				 * The token name
				 */
				name?: string;
				/**
				 * Price data for the token
				 */
				price_data?: {
					/**
					 * The circulating supply of the token
					 */
					circulating_supply?: number;
					/**
					 * The market cap of the token in USD
					 */
					market_cap_usd?: number;
					/**
					 * The percentage change of the token in the last 24 hours
					 */
					percent_change_24h?: number;
					/**
					 * The timestamp of the latest price update
					 */
					price_timestamp?: string;
					/**
					 * The price of the token in USD
					 */
					price_usd?: number;
					/**
					 * The total supply of the token
					 */
					total_supply?: number;
					/**
					 * The volume of the token in USD
					 */
					volume_24h_usd?: number;
				};
				/**
				 * The token symbol
				 */
				symbol?: string;
				/**
				 * The contract address of the token
				 */
				token_address: string;
			}>;
		};
	};
};

export type GetWalletTokensResponse =
	GetWalletTokensResponses[keyof GetWalletTokensResponses];

export type GetWalletNftsData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address, which is a 40-character hexadecimal string (0x prefixed) representing an account on the Ethereum blockchain.
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request NFT data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * The number of NFTs to return per chain (default: 20, max: 500).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 0, max: 20).
		 */
		page?: number;
	};
	url: "/v1/wallets/{address}/nfts";
};

export type GetWalletNftsErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no NFTs available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletNftsResponses = {
	/**
	 * Wallet NFTs retrieved successfully. Returns NFT data with metadata including pagination information and chain details. Includes NFT metadata, attributes, and collection information when available.
	 */
	200: {
		result: {
			/**
			 * Array of wallet NFTs.
			 */
			nfts: Array<{
				/**
				 * The animation URL of the NFT
				 */
				animation_url?: string;
				/**
				 * The attributes/traits of the NFT
				 */
				attributes?: Array<{
					/**
					 * The display type
					 */
					display_type?: string;
					/**
					 * The trait type
					 */
					trait_type?: string;
					/**
					 * The trait value
					 */
					value?: string | number;
				}>;
				/**
				 * The chain ID of the NFT
				 */
				chain_id: number;
				/**
				 * Collection information
				 */
				collection?: {
					/**
					 * The collection description
					 */
					description?: string;
					/**
					 * The collection external URL
					 */
					external_url?: string;
					/**
					 * The collection image URL
					 */
					image?: string;
					/**
					 * The collection name
					 */
					name?: string;
				};
				/**
				 * The description of the NFT
				 */
				description?: string;
				/**
				 * The external URL of the NFT
				 */
				external_url?: string;
				/**
				 * The image URL of the NFT
				 */
				image_url?: string;
				/**
				 * Additional metadata for the NFT
				 */
				metadata?: {
					[key: string]: unknown;
				};
				/**
				 * The name of the NFT
				 */
				name?: string;
				/**
				 * The contract address of the NFT collection
				 */
				token_address: string;
				/**
				 * The token ID of the NFT
				 */
				token_id: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit: number;
				/**
				 * Current page number
				 */
				page: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetWalletNftsResponse =
	GetWalletNftsResponses[keyof GetWalletNftsResponses];

export type GetWalletDetailsData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address, which is a 40-character hexadecimal string (0x prefixed) representing an account on the Ethereum blockchain.
		 */
		address: string;
	};
	query?: never;
	url: "/v1/wallets/{address}";
};

export type GetWalletDetailsErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid or malformed.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Wallet not found. The specified wallet address does not exist or is not associated with any user in the system.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability, network connectivity issues, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletDetailsResponses = {
	/**
	 * Wallet details retrieved successfully. Returns comprehensive user information including authentication details and linked accounts.
	 */
	200: {
		result: {
			/**
			 * The EOA (Externally Owned Account) address of the wallet. This is the traditional wallet address.
			 */
			address: string;
			/**
			 * The date and time the wallet was created
			 */
			createdAt: string;
			/**
			 * The profiles linked to the wallet, can be email, phone, google etc, or backend for developer created wallets
			 */
			profiles: Array<
				| {
						email: string;
						emailVerified: boolean;
						familyName?: string;
						givenName?: string;
						hd: string;
						id: string;
						locale: string;
						name?: string;
						picture: string;
						type: "google";
				  }
				| {
						email?: string;
						firstName?: string;
						id: string;
						lastName?: string;
						name?: string;
						picture?: string;
						type: "facebook";
				  }
				| {
						email?: string;
						emailVerified: boolean;
						id: string;
						isPrivateEmail: boolean;
						type: "apple";
				  }
				| {
						avatar?: string;
						id: string;
						name?: string;
						type: "github";
						username: string;
				  }
				| {
						avatar: string;
						email?: string;
						emailVerified: boolean;
						id: string;
						type: "discord";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						name: string;
						type: "coinbase";
				  }
				| {
						id: string;
						name: string;
						type: "x";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						metadata: {
							avatar: {
								large?: string;
								medium?: string;
								small?: string;
							};
							personaname?: string;
							profileurl?: string;
							realname?: string;
						};
						type: "steam";
						username?: string;
				  }
				| {
						firstName?: string;
						id: string;
						lastName?: string;
						picture?: string;
						type: "telegram";
						username?: string;
				  }
				| {
						avatar?: string;
						description?: string;
						email?: string;
						id: string;
						type: "twitch";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						type: "line";
						username?: string;
				  }
				| {
						fid: string;
						id: string;
						type: "farcaster";
						walletAddress?: string;
				  }
				| {
						algorithm: string;
						credentialId: string;
						publicKey: string;
						type: "passkey";
				  }
				| {
						email: string;
						id: string;
						type: "email";
				  }
				| {
						id: string;
						pregeneratedIdentifier: string;
						type: "pre_generation";
				  }
				| {
						id: string;
						phone: string;
						type: "phone";
				  }
				| {
						id: string;
						type: "siwe";
						walletAddress: string;
				  }
				| {
						id: string;
						type: "guest";
				  }
				| {
						id: string;
						type: "backend";
				  }
				| {
						identifier: string;
						type: "server";
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_jwt";
						walletAddress?: string;
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_auth_endpoint";
						walletAddress?: string;
				  }
			>;
			/**
			 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced account features.
			 */
			smartWalletAddress?: string;
		};
	};
};

export type GetWalletDetailsResponse =
	GetWalletDetailsResponses[keyof GetWalletDetailsResponses];

export type SendCodeData = {
	/**
	 * Request body for sending an OTP code to either email or phone
	 */
	body?:
		| {
				/**
				 * The email address to send the OTP code to
				 */
				email: string;
				/**
				 * Send code to email address
				 */
				type: "email";
		  }
		| {
				/**
				 * The phone number to send the OTP code to
				 */
				phone: string;
				/**
				 * Send code to phone number
				 */
				type: "phone";
		  };
	path?: never;
	query?: never;
	url: "/v1/wallets/login/code";
};

export type SendCodeErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type SendCodeResponses = {
	/**
	 * OTP sent successfully
	 */
	200: {
		success: boolean;
	};
};

export type SendCodeResponse = SendCodeResponses[keyof SendCodeResponses];

export type VerifyCodeData = {
	/**
	 * Request body for verifying an OTP code for either email or phone
	 */
	body?:
		| {
				/**
				 * The 6-digit OTP code sent to the email address
				 */
				code: string;
				/**
				 * The email address to verify
				 */
				email: string;
				/**
				 * Verify code for email address
				 */
				type: "email";
		  }
		| {
				/**
				 * The 6-digit OTP code sent to the phone number
				 */
				code: string;
				/**
				 * The phone number to verify
				 */
				phone: string;
				/**
				 * Verify code for phone number
				 */
				type: "phone";
		  };
	path?: never;
	query?: never;
	url: "/v1/wallets/login/code/verify";
};

export type VerifyCodeErrors = {
	/**
	 * Invalid OTP or request parameters
	 */
	400: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type VerifyCodeResponses = {
	/**
	 * OTP verified successfully
	 */
	200: {
		isNewUser: boolean;
		token: string;
		type: string;
		walletAddress: string;
	};
};

export type VerifyCodeResponse = VerifyCodeResponses[keyof VerifyCodeResponses];

export type InitOauthData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The thirdweb project client ID
		 */
		clientId: string;
		/**
		 * The redirect URL post authentication
		 */
		redirectUrl?: string;
	};
	url: "/v1/wallets/login/oauth/{provider}";
};

export type InitOauthErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type GeneratePasskeyChallengeData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Authentication type for passkey - either sign-up for new users or sign-in for existing users
		 */
		type: "sign-up" | "sign-in";
		/**
		 * Optional username for passkey registration
		 */
		username?: string;
	};
	url: "/v1/wallets/login/passkey";
};

export type GeneratePasskeyChallengeErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type GeneratePasskeyChallengeResponses = {
	/**
	 * Response containing passkey challenge data
	 */
	200: {
		/**
		 * Server verification ID for the passkey challenge
		 */
		serverVerificationId: string;
		/**
		 * Passkey challenge string
		 */
		challenge: string;
		/**
		 * Authentication type for passkey - either sign-up for new users or sign-in for existing users
		 */
		type: "sign-up" | "sign-in";
	};
};

export type GeneratePasskeyChallengeResponse =
	GeneratePasskeyChallengeResponses[keyof GeneratePasskeyChallengeResponses];

export type VerifyPasskeyData = {
	/**
	 * Request body for validating passkey authentication
	 */
	body?: {
		/**
		 * Authentication type for passkey - either sign-up for new users or sign-in for existing users
		 */
		type: "sign-up" | "sign-in";
		/**
		 * Authenticator data from the passkey response
		 */
		authenticatorData: string;
		/**
		 * Credential ID from the passkey response
		 */
		credentialId: string;
		/**
		 * Server verification ID from the challenge
		 */
		serverVerificationId: string;
		/**
		 * Client data from the passkey response
		 */
		clientData: string;
		/**
		 * Origin of the request
		 */
		origin?: string;
		/**
		 * Relying Party ID
		 */
		rpId?: string;
		/**
		 * Signature for passkey sign in
		 */
		signature?: string;
		/**
		 * Username for passkey registration
		 */
		username?: string;
		/**
		 * Credential data for passkey registration
		 */
		credential?: {
			/**
			 * Public key for the credential
			 */
			publicKey: string;
			/**
			 * Algorithm used for the credential
			 */
			algorithm: "RS256" | "ES256";
		};
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/login/passkey/verify";
};

export type VerifyPasskeyErrors = {
	/**
	 * Invalid passkey or request parameters
	 */
	400: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type VerifyPasskeyResponses = {
	/**
	 * Passkey verified successfully
	 */
	200: {
		isNewUser: boolean;
		token: string;
		type: string;
		walletAddress: string;
	};
};

export type VerifyPasskeyResponse =
	VerifyPasskeyResponses[keyof VerifyPasskeyResponses];

export type GenerateSiwePayloadData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The Ethereum wallet address to generate SIWE payload for
		 */
		address: string;
		/**
		 * The chain ID for the SIWE payload
		 */
		chainId: number;
	};
	url: "/v1/wallets/login/siwe";
};

export type GenerateSiwePayloadErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type GenerateSiwePayloadResponses = {
	/**
	 * SIWE (Sign-In with Ethereum) payload structure
	 */
	200: {
		/**
		 * The domain requesting the signature
		 */
		domain: string;
		/**
		 * The Ethereum address performing the signing
		 */
		address: string;
		/**
		 * A human-readable ASCII assertion that the user will sign
		 */
		statement: string;
		/**
		 * A URI referring to the resource that is the subject of the signing
		 */
		uri?: string;
		/**
		 * The current version of the SIWE Message
		 */
		version: string;
		/**
		 * The Chain ID to which the session is bound
		 */
		chain_id?: string;
		/**
		 * A randomized token used to prevent replay attacks
		 */
		nonce: string;
		/**
		 * The time when the message was generated
		 */
		issued_at: string;
		/**
		 * The time when the signed authentication message is no longer valid
		 */
		expiration_time: string;
		/**
		 * The time when the signed authentication message will become valid
		 */
		invalid_before: string;
		/**
		 * A list of information or references to information the user wishes to have resolved
		 */
		resources?: Array<string>;
	};
};

export type GenerateSiwePayloadResponse =
	GenerateSiwePayloadResponses[keyof GenerateSiwePayloadResponses];

export type VerifySiweSignatureData = {
	/**
	 * Request body for verifying SIWE signature
	 */
	body?: {
		/**
		 * The signature generated by signing the SIWE payload
		 */
		signature: string;
		/**
		 * SIWE (Sign-In with Ethereum) payload structure
		 */
		payload: {
			/**
			 * The domain requesting the signature
			 */
			domain: string;
			/**
			 * The Ethereum address performing the signing
			 */
			address: string;
			/**
			 * A human-readable ASCII assertion that the user will sign
			 */
			statement: string;
			/**
			 * A URI referring to the resource that is the subject of the signing
			 */
			uri?: string;
			/**
			 * The current version of the SIWE Message
			 */
			version: string;
			/**
			 * The Chain ID to which the session is bound
			 */
			chain_id?: string;
			/**
			 * A randomized token used to prevent replay attacks
			 */
			nonce: string;
			/**
			 * The time when the message was generated
			 */
			issued_at: string;
			/**
			 * The time when the signed authentication message is no longer valid
			 */
			expiration_time: string;
			/**
			 * The time when the signed authentication message will become valid
			 */
			invalid_before: string;
			/**
			 * A list of information or references to information the user wishes to have resolved
			 */
			resources?: Array<string>;
		};
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/login/siwe/verify";
};

export type VerifySiweSignatureErrors = {
	/**
	 * Invalid signature or request parameters
	 */
	400: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type VerifySiweSignatureResponses = {
	/**
	 * SIWE signature verified successfully
	 */
	200: {
		isNewUser: boolean;
		token: string;
		type: string;
		walletAddress: string;
	};
};

export type VerifySiweSignatureResponse =
	VerifySiweSignatureResponses[keyof VerifySiweSignatureResponses];

export type ListTransactionsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Filter transactions by sender wallet address.
		 */
		from?: string;
		/**
		 * Number of transactions to return per page (1-100).
		 */
		limit?: number;
		/**
		 * Page number for pagination, starting from 1.
		 */
		page?: number;
	};
	url: "/v1/transactions";
};

export type ListTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when pagination parameters are out of range or wallet address format is invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, database unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type ListTransactionsResponses = {
	/**
	 * Transactions retrieved successfully. Returns a paginated list of transactions with metadata including creation and confirmation timestamps.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit: number;
				/**
				 * Current page number
				 */
				page: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			transactions: Array<{
				/**
				 * Index within transaction batch
				 */
				batchIndex: number;
				/**
				 * ISO timestamp when transaction was cancelled, if applicable
				 */
				cancelledAt: string;
				/**
				 * Blockchain network identifier as string
				 */
				chainId: string;
				/**
				 * Client identifier that initiated the transaction
				 */
				clientId: string;
				/**
				 * ISO timestamp when transaction was confirmed on-chain
				 */
				confirmedAt: string;
				/**
				 * Block number where transaction was confirmed
				 */
				confirmedAtBlockNumber: string;
				/**
				 * ISO timestamp when transaction was created
				 */
				createdAt: string;
				/**
				 * Additional metadata and enriched transaction information
				 */
				enrichedData?: unknown;
				/**
				 * Error message if transaction failed
				 */
				errorMessage: string;
				/**
				 * Parameters used for transaction execution
				 */
				executionParams?: unknown;
				/**
				 * Result data from transaction execution
				 */
				executionResult?: unknown;
				/**
				 * Sender wallet address
				 */
				from: string;
				/**
				 * Unique transaction identifier
				 */
				id: string;
				/**
				 * On-chain transaction hash once confirmed
				 */
				transactionHash: string;
				/**
				 * Original transaction parameters and data
				 */
				transactionParams?: unknown;
			}>;
		};
	};
};

export type ListTransactionsResponse =
	ListTransactionsResponses[keyof ListTransactionsResponses];

export type SendTransactionsData = {
	/**
	 * Transaction Request
	 * Request object containing an array of blockchain transactions to execute. All transactions must use the same from address and chainId. Supports batching multiple transactions of different types in a single request.
	 */
	body?: {
		/**
		 * The blockchain network identifier where all transactions will be executed.
		 */
		chainId: number;
		/**
		 * The wallet address that will send the transaction.
		 */
		from: string;
		/**
		 * Transaction
		 * A blockchain transaction of one of three supported types: contract call, encoded transaction, or native token transfer.
		 */
		transactions: Array<
			| {
					/**
					 * The smart contract address to interact with.
					 */
					contractAddress: string;
					/**
					 * The contract function signature to call (e.g., 'function approve(address spender, uint256 amount)'). Must start with 'function' followed by the function name and parameters as defined in the contract ABI.
					 */
					method: string;
					/**
					 * Array of parameters to pass to the contract method, in the correct order and format.
					 */
					params?: Array<unknown>;
					/**
					 * Transaction type for smart contract method calls
					 */
					type: "contract-call";
					/**
					 * Amount of native token to send with the transaction in wei. Required for payable methods.
					 */
					value?: string;
			  }
			| {
					/**
					 * Transaction data in hexadecimal format for contract interactions or custom payloads.
					 */
					data: string;
					/**
					 * The target address for the encoded transaction.
					 */
					to: string;
					/**
					 * Transaction type for pre-encoded transaction data
					 */
					type: "encoded";
					/**
					 * Amount of native token to send in wei (smallest unit). Use '0' or omit for non-value transactions.
					 */
					value?: string;
			  }
			| {
					/**
					 * The recipient wallet address.
					 */
					to: string;
					/**
					 * Transaction type for native token transfers
					 */
					type: "native-transfer";
					/**
					 * Amount of native token to send in wei (smallest unit).
					 */
					value: string;
			  }
		>;
	};
	path?: never;
	query?: never;
	url: "/v1/transactions";
};

export type SendTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when transaction parameters are malformed, insufficient balance, invalid contract data, or unsupported transaction type.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, gas estimation failures, contract execution errors, or unexpected server errors.
	 */
	500: unknown;
};

export type SendTransactionsResponses = {
	/**
	 * Transaction submitted successfully. Returns the transaction ID for tracking and monitoring.
	 */
	200: {
		result: {
			/**
			 * Array of unique identifiers for the submitted transactions. Use these to track transaction status.
			 */
			transactionIds: Array<string>;
		};
	};
};

export type SendTransactionsResponse =
	SendTransactionsResponses[keyof SendTransactionsResponses];

export type GetTransactionByIdData = {
	body?: never;
	path: {
		/**
		 * Unique identifier of the transaction to retrieve.
		 */
		transactionId: string;
	};
	query?: never;
	url: "/v1/transactions/{transactionId}";
};

export type GetTransactionByIdErrors = {
	/**
	 * Invalid request parameters. This occurs when the transaction ID format is invalid or malformed.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or x-secret-key for backend usage.
	 */
	401: unknown;
	/**
	 * Transaction not found. The specified transaction ID does not exist or is not associated with the authenticated client.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, database unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetTransactionByIdResponses = {
	/**
	 * Transaction details retrieved successfully. Returns comprehensive transaction information including status, blockchain details, and execution metadata.
	 */
	200: {
		result: {
			/**
			 * Index within transaction batch
			 */
			batchIndex: number;
			/**
			 * ISO timestamp when transaction was cancelled, if applicable
			 */
			cancelledAt: string;
			/**
			 * Blockchain network identifier as string
			 */
			chainId: string;
			/**
			 * Client identifier that initiated the transaction
			 */
			clientId: string;
			/**
			 * ISO timestamp when transaction was confirmed on-chain
			 */
			confirmedAt: string;
			/**
			 * Block number where transaction was confirmed
			 */
			confirmedAtBlockNumber: string;
			/**
			 * ISO timestamp when transaction was created
			 */
			createdAt: string;
			/**
			 * Additional metadata and enriched transaction information
			 */
			enrichedData?: unknown;
			/**
			 * Error message if transaction failed
			 */
			errorMessage: string;
			/**
			 * Parameters used for transaction execution
			 */
			executionParams?: unknown;
			/**
			 * Result data from transaction execution
			 */
			executionResult?: unknown;
			/**
			 * Sender wallet address
			 */
			from: string;
			/**
			 * Unique transaction identifier
			 */
			id: string;
			/**
			 * On-chain transaction hash once confirmed
			 */
			transactionHash: string;
			/**
			 * Original transaction parameters and data
			 */
			transactionParams?: unknown;
		};
	};
};

export type GetTransactionByIdResponse =
	GetTransactionByIdResponses[keyof GetTransactionByIdResponses];

export type SignMessageData = {
	body?: {
		/**
		 * The blockchain network identifier where the signing will occur. Common values include: 1 (Ethereum), 137 (Polygon), 56 (BSC).
		 */
		chainId: number;
		/**
		 * The wallet address that will sign the message.
		 */
		from: string;
		/**
		 * The message to be signed. Can be plain text or hexadecimal format (starting with 0x). The format is automatically detected.
		 */
		message: string;
	};
	path?: never;
	query?: never;
	url: "/v1/sign/message";
};

export type SignMessageErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId is not supported, or the message format is incorrect.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet connectivity issues, signing service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type SignMessageResponses = {
	/**
	 * Message signed successfully. Returns the cryptographic signature that can be used for verification.
	 */
	200: {
		result: {
			/**
			 * The cryptographic signature in hexadecimal format. This can be used for verification and authentication purposes.
			 */
			signature: string;
		};
	};
};

export type SignMessageResponse =
	SignMessageResponses[keyof SignMessageResponses];

export type SignTypedDataData = {
	body?: {
		/**
		 * The blockchain network identifier for EIP-712 domain separation.
		 */
		chainId: number;
		/**
		 * EIP-712 domain separator containing contract and chain information for signature verification.
		 */
		domain: {
			/**
			 * Chain ID as string for domain separation
			 */
			chainId?: string;
			/**
			 * The domain name (e.g., token name)
			 */
			name?: string;
			/**
			 * Optional salt for additional entropy
			 */
			salt?: string;
			/**
			 * The contract address that will verify this signature
			 */
			verifyingContract?: string;
			/**
			 * Domain version for signature compatibility
			 */
			version?: string;
		};
		/**
		 * The wallet address that will sign the typed data.
		 */
		from: string;
		/**
		 * The structured data to be signed, matching the defined types schema.
		 */
		message: {
			[key: string]: unknown;
		};
		/**
		 * The primary type name from the types object that defines the main structure being signed.
		 */
		primaryType: string;
		/**
		 * Type definitions for the structured data, following EIP-712 specifications.
		 */
		types: {
			[key: string]: Array<{
				/**
				 * The field name
				 */
				name: string;
				/**
				 * The Solidity type (e.g., 'address', 'uint256')
				 */
				type: string;
			}>;
		};
	};
	path?: never;
	query?: never;
	url: "/v1/sign/typed-data";
};

export type SignTypedDataErrors = {
	/**
	 * Invalid request parameters. This occurs when the typed data structure is malformed, domain parameters are incorrect, or wallet address format is invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include valid `x-wallet-access-token` headers for accessing the wallet, as well as a x-client-id (frontend) or x-secret-key (backend) for project authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet connectivity issues, signing service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type SignTypedDataResponses = {
	/**
	 * Typed data signed successfully. Returns the EIP-712 compliant signature that can be used for on-chain verification.
	 */
	200: {
		result: {
			/**
			 * The cryptographic signature in hexadecimal format. This can be used for verification and authentication purposes.
			 */
			signature: string;
		};
	};
};

export type SignTypedDataResponse =
	SignTypedDataResponses[keyof SignTypedDataResponses];

export type BuyTokenWithUsdData = {
	/**
	 * Buy Token Request
	 * Request to buy tokens using a USD amount. The system will automatically use your wallet balance to purchase the specified tokens.
	 */
	body?: {
		/**
		 * The USD amount to spend on the token purchase (as string to support decimals)
		 */
		amountUsd: string;
		/**
		 * The blockchain network where the token will be received
		 */
		chainId: number;
		/**
		 * The wallet address that will buy the tokens.
		 */
		from: string;
		/**
		 * The token address to purchase (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
		 */
		tokenAddress: string;
	};
	path?: never;
	query?: never;
	url: "/v1/tokens/buy";
};

export type BuyTokenWithUsdErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment required. Insufficient wallet balance to complete the purchase.
	 */
	402: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type BuyTokenWithUsdResponses = {
	/**
	 * Buy Token Response
	 * Successful token purchase response containing executed transaction IDs
	 */
	200: {
		result: {
			/**
			 * Transaction IDs that were executed for your token purchase
			 */
			transactionIds: Array<string>;
		};
	};
};

export type BuyTokenWithUsdResponse =
	BuyTokenWithUsdResponses[keyof BuyTokenWithUsdResponses];

export type SellTokenForUsdData = {
	/**
	 * Sell Token Request
	 * Request to sell tokens for USD value. The system will automatically convert your tokens to USDC on Arbitrum.
	 */
	body?: {
		/**
		 * The USD amount worth of tokens to sell (as string to support decimals)
		 */
		amountUsd: string;
		/**
		 * The blockchain network where the token is located
		 */
		chainId: number;
		/**
		 * The wallet address that will send the transaction.
		 */
		from: string;
		/**
		 * The token address to sell (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
		 */
		tokenAddress: string;
	};
	path?: never;
	query?: never;
	url: "/v1/tokens/sell";
};

export type SellTokenForUsdErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment required. Insufficient token balance to complete the sale.
	 */
	402: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type SellTokenForUsdResponses = {
	/**
	 * Sell Token Response
	 * Successful token sale response containing executed transaction IDs
	 */
	200: {
		result: {
			/**
			 * Transaction IDs that were executed for your token sale
			 */
			transactionIds: Array<string>;
		};
	};
};

export type SellTokenForUsdResponse =
	SellTokenForUsdResponses[keyof SellTokenForUsdResponses];

export type TransferTokenWithUsdData = {
	/**
	 * Transfer Token Request
	 * Request to transfer tokens worth a USD amount to another wallet address. The system will calculate the token amount based on current prices and transfer the tokens.
	 */
	body?: {
		/**
		 * The USD amount worth of tokens to transfer (as string to support decimals)
		 */
		amountUsd: string;
		/**
		 * The blockchain network where the token is located
		 */
		chainId: number;
		/**
		 * The wallet address that will send the transaction.
		 */
		from: string;
		/**
		 * The wallet address that will receive the transferred tokens
		 */
		to: string;
		/**
		 * The token address to transfer (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
		 */
		tokenAddress: string;
	};
	path?: never;
	query?: never;
	url: "/v1/tokens/transfer";
};

export type TransferTokenWithUsdErrors = {
	/**
	 * Invalid request parameters or insufficient token balance.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment required. Insufficient wallet balance to complete the transfer.
	 */
	402: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type TransferTokenWithUsdResponses = {
	/**
	 * Transfer Token Response
	 * Successful token transfer response containing executed transaction IDs
	 */
	200: {
		result: {
			/**
			 * Transaction IDs that were executed for your token transfer
			 */
			transactionIds: Array<string>;
		};
	};
};

export type TransferTokenWithUsdResponse =
	TransferTokenWithUsdResponses[keyof TransferTokenWithUsdResponses];

export type ClientOptions = {
	baseUrl: "https://api.thirdweb.com" | "http://localhost:3030" | (string & {});
};
