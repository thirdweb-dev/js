// This file is auto-generated by @hey-api/openapi-ts

export type GetV1WebhooksData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The webhook ID to request the data for
     */
    webhook_id?: string;
  };
  url: "/v1/webhooks";
};

export type GetV1WebhooksErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1WebhooksError = GetV1WebhooksErrors[keyof GetV1WebhooksErrors];

export type GetV1WebhooksResponses = {
  /**
   * Successful response
   */
  200: {
    data: Array<{
      id: string;
      team_id: string;
      project_id: string;
      webhook_url: string;
      webhook_secret: string;
      filters: string | number | boolean | unknown | {} | Array<unknown>;
      suspended_at: string | null;
      suspended_reason: string | null;
      disabled: boolean;
      created_at: string;
      updated_at: string | null;
    }>;
  };
};

export type GetV1WebhooksResponse =
  GetV1WebhooksResponses[keyof GetV1WebhooksResponses];

export type PostV1WebhooksData = {
  body?: {
    webhook_url: string;
    filters: {
      "v1.events"?: {
        chain_ids?: Array<string>;
        addresses?: Array<string>;
        signatures?: Array<{
          sig_hash: string;
          abi?: string;
          params?: {};
        }>;
      };
      "v1.transactions"?: {
        chain_ids?: Array<string>;
        from_addresses?: Array<string>;
        to_addresses?: Array<string>;
        signatures?: Array<{
          sig_hash: string;
          abi?: string;
          params?: Array<string>;
        }>;
      };
    };
  };
  path?: never;
  query?: never;
  url: "/v1/webhooks";
};

export type PostV1WebhooksErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type PostV1WebhooksError =
  PostV1WebhooksErrors[keyof PostV1WebhooksErrors];

export type PostV1WebhooksResponses = {
  /**
   * Successful response
   */
  200: {
    data: {
      id: string;
      team_id: string;
      project_id: string;
      webhook_url: string;
      webhook_secret: string;
      filters: string | number | boolean | unknown | {} | Array<unknown>;
      suspended_at: string | null;
      suspended_reason: string | null;
      disabled: boolean;
      created_at: string;
      updated_at: string | null;
    };
  };
};

export type PostV1WebhooksResponse =
  PostV1WebhooksResponses[keyof PostV1WebhooksResponses];

export type DeleteV1WebhooksByWebhookIdData = {
  body?: never;
  path: {
    webhook_id: string;
  };
  query?: never;
  url: "/v1/webhooks/{webhook_id}";
};

export type DeleteV1WebhooksByWebhookIdErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Webhook not found
   */
  404: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type DeleteV1WebhooksByWebhookIdError =
  DeleteV1WebhooksByWebhookIdErrors[keyof DeleteV1WebhooksByWebhookIdErrors];

export type DeleteV1WebhooksByWebhookIdResponses = {
  /**
   * Successful response
   */
  200: {
    data: {
      id: string;
      team_id: string;
      project_id: string;
      webhook_url: string;
      webhook_secret: string;
      filters: string | number | boolean | unknown | {} | Array<unknown>;
      suspended_at: string | null;
      suspended_reason: string | null;
      disabled: boolean;
      created_at: string;
      updated_at: string | null;
    };
  };
};

export type DeleteV1WebhooksByWebhookIdResponse =
  DeleteV1WebhooksByWebhookIdResponses[keyof DeleteV1WebhooksByWebhookIdResponses];

export type PatchV1WebhooksByWebhookIdData = {
  body?: {
    webhook_url?: string;
    filters?: {
      "v1.events"?: {
        chain_ids?: Array<string>;
        addresses?: Array<string>;
        signatures?: Array<{
          sig_hash: string;
          abi?: string;
          params?: {};
        }>;
      };
      "v1.transactions"?: {
        chain_ids?: Array<string>;
        from_addresses?: Array<string>;
        to_addresses?: Array<string>;
        signatures?: Array<{
          sig_hash: string;
          abi?: string;
          params?: Array<string>;
        }>;
      };
    };
    disabled?: boolean;
  };
  path: {
    webhook_id: string;
  };
  query?: never;
  url: "/v1/webhooks/{webhook_id}";
};

export type PatchV1WebhooksByWebhookIdErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Webhook not found
   */
  404: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type PatchV1WebhooksByWebhookIdError =
  PatchV1WebhooksByWebhookIdErrors[keyof PatchV1WebhooksByWebhookIdErrors];

export type PatchV1WebhooksByWebhookIdResponses = {
  /**
   * Successful response
   */
  200: {
    data: {
      id: string;
      team_id: string;
      project_id: string;
      webhook_url: string;
      webhook_secret: string;
      filters: string | number | boolean | unknown | {} | Array<unknown>;
      suspended_at: string | null;
      suspended_reason: string | null;
      disabled: boolean;
      created_at: string;
      updated_at: string | null;
    };
  };
};

export type PatchV1WebhooksByWebhookIdResponse =
  PatchV1WebhooksByWebhookIdResponses[keyof PatchV1WebhooksByWebhookIdResponses];

export type PostV1WebhooksByWebhookIdVerifyData = {
  body?: never;
  path: {
    webhook_id: string;
  };
  query: {
    otp: string;
  };
  url: "/v1/webhooks/{webhook_id}/verify";
};

export type PostV1WebhooksByWebhookIdVerifyErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Webhook not found
   */
  404: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type PostV1WebhooksByWebhookIdVerifyError =
  PostV1WebhooksByWebhookIdVerifyErrors[keyof PostV1WebhooksByWebhookIdVerifyErrors];

export type PostV1WebhooksByWebhookIdVerifyResponses = {
  /**
   * Successful response
   */
  200: {
    success: boolean;
  };
};

export type PostV1WebhooksByWebhookIdVerifyResponse =
  PostV1WebhooksByWebhookIdVerifyResponses[keyof PostV1WebhooksByWebhookIdVerifyResponses];

export type PostV1WebhooksByWebhookIdResendOtpData = {
  body?: never;
  path: {
    webhook_id: string;
  };
  query?: never;
  url: "/v1/webhooks/{webhook_id}/resend-otp";
};

export type PostV1WebhooksByWebhookIdResendOtpErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Webhook not found
   */
  404: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type PostV1WebhooksByWebhookIdResendOtpError =
  PostV1WebhooksByWebhookIdResendOtpErrors[keyof PostV1WebhooksByWebhookIdResendOtpErrors];

export type PostV1WebhooksByWebhookIdResendOtpResponses = {
  /**
   * OTP code resent successfully
   */
  200: {
    success: boolean;
  };
};

export type PostV1WebhooksByWebhookIdResendOtpResponse =
  PostV1WebhooksByWebhookIdResendOtpResponses[keyof PostV1WebhooksByWebhookIdResendOtpResponses];

export type PostV1WebhooksTestData = {
  body?: {
    webhook_url: string;
    type?: "event" | "transaction";
  };
  path?: never;
  query?: never;
  url: "/v1/webhooks/test";
};

export type PostV1WebhooksTestErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Rate limit exceeded
   */
  429: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type PostV1WebhooksTestError =
  PostV1WebhooksTestErrors[keyof PostV1WebhooksTestErrors];

export type PostV1WebhooksTestResponses = {
  /**
   * Test event sent successfully
   */
  200: {
    success: boolean;
  };
};

export type PostV1WebhooksTestResponse =
  PostV1WebhooksTestResponses[keyof PostV1WebhooksTestResponses];

export type GetV1EventsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Filter by block number
     */
    filter_block_number?: number | null;
    /**
     * Filter by block number greater than or equal to
     */
    filter_block_number_gte?: number | null;
    /**
     * Filter by block number greater than
     */
    filter_block_number_gt?: number | null;
    /**
     * Filter by block number less than or equal to
     */
    filter_block_number_lte?: number | null;
    /**
     * Filter by block number less than
     */
    filter_block_number_lt?: number | null;
    /**
     * Filter by block hash
     */
    filter_block_hash?: string;
    /**
     * Filter by block timestamp
     */
    filter_block_timestamp?: number | null;
    /**
     * Filter by block timestamp greater than or equal to
     */
    filter_block_timestamp_gte?: number | null;
    /**
     * Filter by block timestamp greater than
     */
    filter_block_timestamp_gt?: number | null;
    /**
     * Filter by block timestamp less than or equal to
     */
    filter_block_timestamp_lte?: number | null;
    /**
     * Filter by block timestamp less than
     */
    filter_block_timestamp_lt?: number | null;
    /**
     * Field to sort results by
     */
    sort_by?: "block_number" | string;
    /**
     * Sort order (asc or desc)
     */
    sort_order?: "asc" | "desc";
    group_by?: Array<string | null> | (string | null) | unknown;
    aggregate?: Array<string | null> | (string | null) | unknown;
    /**
     * Filter by transaction index
     */
    filter_transaction_index?: number | null;
    /**
     * Filter by transaction index greater than or equal to
     */
    filter_transaction_index_gte?: number | null;
    /**
     * Filter by transaction index greater than
     */
    filter_transaction_index_gt?: number | null;
    /**
     * Filter by transaction index less than or equal to
     */
    filter_transaction_index_lte?: number | null;
    /**
     * Filter by transaction index less than
     */
    filter_transaction_index_lt?: number | null;
    /**
     * Enable ABI decoding of the transactions/events data
     */
    decode?: boolean | null;
    /**
     * Filter by transaction hash
     */
    filter_transaction_hash?: string;
    /**
     * Filter by log index
     */
    filter_log_index?: number | null;
    /**
     * Filter by log index greater than or equal to
     */
    filter_log_index_gte?: number | null;
    /**
     * Filter by log index greater than
     */
    filter_log_index_gt?: number | null;
    /**
     * Filter by log index less than or equal to
     */
    filter_log_index_lte?: number | null;
    /**
     * Filter by log index less than
     */
    filter_log_index_lt?: number | null;
    /**
     * Filter by topic 1
     */
    filter_topic_1?: string;
    /**
     * Filter by topic 2
     */
    filter_topic_2?: string;
    /**
     * Filter by topic 3
     */
    filter_topic_3?: string;
    /**
     * Filter by topic 0
     */
    filter_topic_0?: string;
    /**
     * Filter by address
     */
    filter_address?: string;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/events";
};

export type GetV1EventsErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1EventsError = GetV1EventsErrors[keyof GetV1EventsErrors];

export type GetV1EventsResponses = {
  /**
   * Successful response
   */
  200: {
    data?: Array<{
      chain_id: number;
      block_number: string;
      block_hash: string;
      block_timestamp: string;
      transaction_hash: string;
      transaction_index: number;
      log_index: number;
      address: string;
      data: string;
      topics: Array<string>;
      decoded?: {
        name: string;
        signature: string;
        indexed_params: {
          [key: string]: unknown;
        };
        non_indexed_params: {
          [key: string]: unknown;
        };
      };
    }>;
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1EventsResponse =
  GetV1EventsResponses[keyof GetV1EventsResponses];

export type GetV1EventsByContractAddressData = {
  body?: never;
  path: {
    contractAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Filter by block number
     */
    filter_block_number?: number | null;
    /**
     * Filter by block number greater than or equal to
     */
    filter_block_number_gte?: number | null;
    /**
     * Filter by block number greater than
     */
    filter_block_number_gt?: number | null;
    /**
     * Filter by block number less than or equal to
     */
    filter_block_number_lte?: number | null;
    /**
     * Filter by block number less than
     */
    filter_block_number_lt?: number | null;
    /**
     * Filter by block hash
     */
    filter_block_hash?: string;
    /**
     * Filter by block timestamp
     */
    filter_block_timestamp?: number | null;
    /**
     * Filter by block timestamp greater than or equal to
     */
    filter_block_timestamp_gte?: number | null;
    /**
     * Filter by block timestamp greater than
     */
    filter_block_timestamp_gt?: number | null;
    /**
     * Filter by block timestamp less than or equal to
     */
    filter_block_timestamp_lte?: number | null;
    /**
     * Filter by block timestamp less than
     */
    filter_block_timestamp_lt?: number | null;
    /**
     * Field to sort results by
     */
    sort_by?: "block_number" | string;
    /**
     * Sort order (asc or desc)
     */
    sort_order?: "asc" | "desc";
    group_by?: Array<string | null> | (string | null) | unknown;
    aggregate?: Array<string | null> | (string | null) | unknown;
    /**
     * Filter by transaction index
     */
    filter_transaction_index?: number | null;
    /**
     * Filter by transaction index greater than or equal to
     */
    filter_transaction_index_gte?: number | null;
    /**
     * Filter by transaction index greater than
     */
    filter_transaction_index_gt?: number | null;
    /**
     * Filter by transaction index less than or equal to
     */
    filter_transaction_index_lte?: number | null;
    /**
     * Filter by transaction index less than
     */
    filter_transaction_index_lt?: number | null;
    /**
     * Enable ABI decoding of the transactions/events data
     */
    decode?: boolean | null;
    /**
     * Filter by transaction hash
     */
    filter_transaction_hash?: string;
    /**
     * Filter by log index
     */
    filter_log_index?: number | null;
    /**
     * Filter by log index greater than or equal to
     */
    filter_log_index_gte?: number | null;
    /**
     * Filter by log index greater than
     */
    filter_log_index_gt?: number | null;
    /**
     * Filter by log index less than or equal to
     */
    filter_log_index_lte?: number | null;
    /**
     * Filter by log index less than
     */
    filter_log_index_lt?: number | null;
    /**
     * Filter by topic 1
     */
    filter_topic_1?: string;
    /**
     * Filter by topic 2
     */
    filter_topic_2?: string;
    /**
     * Filter by topic 3
     */
    filter_topic_3?: string;
    /**
     * Filter by topic 0
     */
    filter_topic_0?: string;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/events/{contractAddress}";
};

export type GetV1EventsByContractAddressErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1EventsByContractAddressError =
  GetV1EventsByContractAddressErrors[keyof GetV1EventsByContractAddressErrors];

export type GetV1EventsByContractAddressResponses = {
  /**
   * Successful response
   */
  200: {
    data?: Array<{
      chain_id: number;
      block_number: string;
      block_hash: string;
      block_timestamp: string;
      transaction_hash: string;
      transaction_index: number;
      log_index: number;
      address: string;
      data: string;
      topics: Array<string>;
      decoded?: {
        name: string;
        signature: string;
        indexed_params: {
          [key: string]: unknown;
        };
        non_indexed_params: {
          [key: string]: unknown;
        };
      };
    }>;
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1EventsByContractAddressResponse =
  GetV1EventsByContractAddressResponses[keyof GetV1EventsByContractAddressResponses];

export type GetV1EventsByContractAddressBySignatureData = {
  body?: never;
  path: {
    contractAddress: string;
    signature: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Filter by block number
     */
    filter_block_number?: number | null;
    /**
     * Filter by block number greater than or equal to
     */
    filter_block_number_gte?: number | null;
    /**
     * Filter by block number greater than
     */
    filter_block_number_gt?: number | null;
    /**
     * Filter by block number less than or equal to
     */
    filter_block_number_lte?: number | null;
    /**
     * Filter by block number less than
     */
    filter_block_number_lt?: number | null;
    /**
     * Filter by block hash
     */
    filter_block_hash?: string;
    /**
     * Filter by block timestamp
     */
    filter_block_timestamp?: number | null;
    /**
     * Filter by block timestamp greater than or equal to
     */
    filter_block_timestamp_gte?: number | null;
    /**
     * Filter by block timestamp greater than
     */
    filter_block_timestamp_gt?: number | null;
    /**
     * Filter by block timestamp less than or equal to
     */
    filter_block_timestamp_lte?: number | null;
    /**
     * Filter by block timestamp less than
     */
    filter_block_timestamp_lt?: number | null;
    /**
     * Field to sort results by
     */
    sort_by?: "block_number" | string;
    /**
     * Sort order (asc or desc)
     */
    sort_order?: "asc" | "desc";
    group_by?: Array<string | null> | (string | null) | unknown;
    aggregate?: Array<string | null> | (string | null) | unknown;
    /**
     * Filter by transaction index
     */
    filter_transaction_index?: number | null;
    /**
     * Filter by transaction index greater than or equal to
     */
    filter_transaction_index_gte?: number | null;
    /**
     * Filter by transaction index greater than
     */
    filter_transaction_index_gt?: number | null;
    /**
     * Filter by transaction index less than or equal to
     */
    filter_transaction_index_lte?: number | null;
    /**
     * Filter by transaction index less than
     */
    filter_transaction_index_lt?: number | null;
    /**
     * Enable ABI decoding of the transactions/events data
     */
    decode?: boolean | null;
    /**
     * Filter by transaction hash
     */
    filter_transaction_hash?: string;
    /**
     * Filter by log index
     */
    filter_log_index?: number | null;
    /**
     * Filter by log index greater than or equal to
     */
    filter_log_index_gte?: number | null;
    /**
     * Filter by log index greater than
     */
    filter_log_index_gt?: number | null;
    /**
     * Filter by log index less than or equal to
     */
    filter_log_index_lte?: number | null;
    /**
     * Filter by log index less than
     */
    filter_log_index_lt?: number | null;
    /**
     * Filter by topic 1
     */
    filter_topic_1?: string;
    /**
     * Filter by topic 2
     */
    filter_topic_2?: string;
    /**
     * Filter by topic 3
     */
    filter_topic_3?: string;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/events/{contractAddress}/{signature}";
};

export type GetV1EventsByContractAddressBySignatureErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1EventsByContractAddressBySignatureError =
  GetV1EventsByContractAddressBySignatureErrors[keyof GetV1EventsByContractAddressBySignatureErrors];

export type GetV1EventsByContractAddressBySignatureResponses = {
  /**
   * Successful response
   */
  200: {
    data?: Array<{
      chain_id: number;
      block_number: string;
      block_hash: string;
      block_timestamp: string;
      transaction_hash: string;
      transaction_index: number;
      log_index: number;
      address: string;
      data: string;
      topics: Array<string>;
      decoded?: {
        name: string;
        signature: string;
        indexed_params: {
          [key: string]: unknown;
        };
        non_indexed_params: {
          [key: string]: unknown;
        };
      };
    }>;
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1EventsByContractAddressBySignatureResponse =
  GetV1EventsByContractAddressBySignatureResponses[keyof GetV1EventsByContractAddressBySignatureResponses];

export type GetV1TransactionsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Filter by block number
     */
    filter_block_number?: number | null;
    /**
     * Filter by block number greater than or equal to
     */
    filter_block_number_gte?: number | null;
    /**
     * Filter by block number greater than
     */
    filter_block_number_gt?: number | null;
    /**
     * Filter by block number less than or equal to
     */
    filter_block_number_lte?: number | null;
    /**
     * Filter by block number less than
     */
    filter_block_number_lt?: number | null;
    /**
     * Filter by block hash
     */
    filter_block_hash?: string;
    /**
     * Filter by block timestamp
     */
    filter_block_timestamp?: number | null;
    /**
     * Filter by block timestamp greater than or equal to
     */
    filter_block_timestamp_gte?: number | null;
    /**
     * Filter by block timestamp greater than
     */
    filter_block_timestamp_gt?: number | null;
    /**
     * Filter by block timestamp less than or equal to
     */
    filter_block_timestamp_lte?: number | null;
    /**
     * Filter by block timestamp less than
     */
    filter_block_timestamp_lt?: number | null;
    /**
     * Field to sort results by
     */
    sort_by?: "block_number" | string;
    /**
     * Sort order (asc or desc)
     */
    sort_order?: "asc" | "desc";
    group_by?: Array<string | null> | (string | null) | unknown;
    aggregate?: Array<string | null> | (string | null) | unknown;
    /**
     * Filter by transaction index
     */
    filter_transaction_index?: number | null;
    /**
     * Filter by transaction index greater than or equal to
     */
    filter_transaction_index_gte?: number | null;
    /**
     * Filter by transaction index greater than
     */
    filter_transaction_index_gt?: number | null;
    /**
     * Filter by transaction index less than or equal to
     */
    filter_transaction_index_lte?: number | null;
    /**
     * Filter by transaction index less than
     */
    filter_transaction_index_lt?: number | null;
    /**
     * Enable ABI decoding of the transactions/events data
     */
    decode?: boolean | null;
    /**
     * Filter by transaction hash
     */
    filter_hash?: string;
    /**
     * Filter by from address
     */
    filter_from_address?: string;
    /**
     * Filter by value
     */
    filter_value?: number | null;
    /**
     * Filter by value greater than or equal to
     */
    filter_value_gte?: number | null;
    /**
     * Filter by value greater than
     */
    filter_value_gt?: number | null;
    /**
     * Filter by value less than or equal to
     */
    filter_value_lte?: number | null;
    /**
     * Filter by value less than
     */
    filter_value_lt?: number | null;
    /**
     * Filter by gas price
     */
    filter_gas_price?: number | null;
    /**
     * Filter by gas price greater than or equal to
     */
    filter_gas_price_gte?: number | null;
    /**
     * Filter by gas price greater than
     */
    filter_gas_price_gt?: number | null;
    /**
     * Filter by gas price less than or equal to
     */
    filter_gas_price_lte?: number | null;
    /**
     * Filter by gas price less than
     */
    filter_gas_price_lt?: number | null;
    /**
     * Filter by gas
     */
    filter_gas?: number | null;
    /**
     * Filter by gas greater than or equal to
     */
    filter_gas_gte?: number | null;
    /**
     * Filter by gas greater than
     */
    filter_gas_gt?: number | null;
    /**
     * Filter by gas less than or equal to
     */
    filter_gas_lte?: number | null;
    /**
     * Filter by gas less than
     */
    filter_gas_lt?: number | null;
    /**
     * Filter by function selector
     */
    filter_function_selector?: string;
    /**
     * Filter by to address
     */
    filter_to_address?: string;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/transactions";
};

export type GetV1TransactionsErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1TransactionsError =
  GetV1TransactionsErrors[keyof GetV1TransactionsErrors];

export type GetV1TransactionsResponses = {
  /**
   * Successful response
   */
  200: {
    data?: Array<{
      chain_id: number;
      block_number: string;
      block_hash: string;
      block_timestamp: string;
      hash: string;
      nonce: number;
      transaction_index: number;
      from_address: string;
      to_address: string;
      value: number;
      gas_price: number;
      gas: number;
      function_selector: string;
      data: string;
      max_fee_per_gas: number;
      max_priority_fee_per_gas: number;
      transaction_type: number;
      r: number;
      s: number;
      v: number;
      access_list_json?: string;
      contract_address?: string;
      gas_used?: number;
      cumulative_gas_used?: number;
      effective_gas_price?: number;
      blob_gas_used?: number;
      blob_gas_price?: number;
      logs_bloom?: string;
      status?: number;
      decoded?: {
        name: string;
        signature: string;
        inputs?: {};
      };
      /**
       * @deprecated
       */
      decodedData?: {
        name: string;
        signature: string;
        inputs?: {};
      };
    }>;
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1TransactionsResponse =
  GetV1TransactionsResponses[keyof GetV1TransactionsResponses];

export type GetV1TransactionsByContractAddressData = {
  body?: never;
  path: {
    contractAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Filter by block number
     */
    filter_block_number?: number | null;
    /**
     * Filter by block number greater than or equal to
     */
    filter_block_number_gte?: number | null;
    /**
     * Filter by block number greater than
     */
    filter_block_number_gt?: number | null;
    /**
     * Filter by block number less than or equal to
     */
    filter_block_number_lte?: number | null;
    /**
     * Filter by block number less than
     */
    filter_block_number_lt?: number | null;
    /**
     * Filter by block hash
     */
    filter_block_hash?: string;
    /**
     * Filter by block timestamp
     */
    filter_block_timestamp?: number | null;
    /**
     * Filter by block timestamp greater than or equal to
     */
    filter_block_timestamp_gte?: number | null;
    /**
     * Filter by block timestamp greater than
     */
    filter_block_timestamp_gt?: number | null;
    /**
     * Filter by block timestamp less than or equal to
     */
    filter_block_timestamp_lte?: number | null;
    /**
     * Filter by block timestamp less than
     */
    filter_block_timestamp_lt?: number | null;
    /**
     * Field to sort results by
     */
    sort_by?: "block_number" | string;
    /**
     * Sort order (asc or desc)
     */
    sort_order?: "asc" | "desc";
    group_by?: Array<string | null> | (string | null) | unknown;
    aggregate?: Array<string | null> | (string | null) | unknown;
    /**
     * Filter by transaction index
     */
    filter_transaction_index?: number | null;
    /**
     * Filter by transaction index greater than or equal to
     */
    filter_transaction_index_gte?: number | null;
    /**
     * Filter by transaction index greater than
     */
    filter_transaction_index_gt?: number | null;
    /**
     * Filter by transaction index less than or equal to
     */
    filter_transaction_index_lte?: number | null;
    /**
     * Filter by transaction index less than
     */
    filter_transaction_index_lt?: number | null;
    /**
     * Enable ABI decoding of the transactions/events data
     */
    decode?: boolean | null;
    /**
     * Filter by transaction hash
     */
    filter_hash?: string;
    /**
     * Filter by from address
     */
    filter_from_address?: string;
    /**
     * Filter by value
     */
    filter_value?: number | null;
    /**
     * Filter by value greater than or equal to
     */
    filter_value_gte?: number | null;
    /**
     * Filter by value greater than
     */
    filter_value_gt?: number | null;
    /**
     * Filter by value less than or equal to
     */
    filter_value_lte?: number | null;
    /**
     * Filter by value less than
     */
    filter_value_lt?: number | null;
    /**
     * Filter by gas price
     */
    filter_gas_price?: number | null;
    /**
     * Filter by gas price greater than or equal to
     */
    filter_gas_price_gte?: number | null;
    /**
     * Filter by gas price greater than
     */
    filter_gas_price_gt?: number | null;
    /**
     * Filter by gas price less than or equal to
     */
    filter_gas_price_lte?: number | null;
    /**
     * Filter by gas price less than
     */
    filter_gas_price_lt?: number | null;
    /**
     * Filter by gas
     */
    filter_gas?: number | null;
    /**
     * Filter by gas greater than or equal to
     */
    filter_gas_gte?: number | null;
    /**
     * Filter by gas greater than
     */
    filter_gas_gt?: number | null;
    /**
     * Filter by gas less than or equal to
     */
    filter_gas_lte?: number | null;
    /**
     * Filter by gas less than
     */
    filter_gas_lt?: number | null;
    /**
     * Filter by function selector
     */
    filter_function_selector?: string;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/transactions/{contractAddress}";
};

export type GetV1TransactionsByContractAddressErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1TransactionsByContractAddressError =
  GetV1TransactionsByContractAddressErrors[keyof GetV1TransactionsByContractAddressErrors];

export type GetV1TransactionsByContractAddressResponses = {
  /**
   * Successful response
   */
  200: {
    data?: Array<{
      chain_id: number;
      block_number: string;
      block_hash: string;
      block_timestamp: string;
      hash: string;
      nonce: number;
      transaction_index: number;
      from_address: string;
      to_address: string;
      value: number;
      gas_price: number;
      gas: number;
      function_selector: string;
      data: string;
      max_fee_per_gas: number;
      max_priority_fee_per_gas: number;
      transaction_type: number;
      r: number;
      s: number;
      v: number;
      access_list_json?: string;
      contract_address?: string;
      gas_used?: number;
      cumulative_gas_used?: number;
      effective_gas_price?: number;
      blob_gas_used?: number;
      blob_gas_price?: number;
      logs_bloom?: string;
      status?: number;
    }>;
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1TransactionsByContractAddressResponse =
  GetV1TransactionsByContractAddressResponses[keyof GetV1TransactionsByContractAddressResponses];

export type GetV1TransactionsByContractAddressBySignatureData = {
  body?: never;
  path: {
    contractAddress: string;
    signature: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Filter by block number
     */
    filter_block_number?: number | null;
    /**
     * Filter by block number greater than or equal to
     */
    filter_block_number_gte?: number | null;
    /**
     * Filter by block number greater than
     */
    filter_block_number_gt?: number | null;
    /**
     * Filter by block number less than or equal to
     */
    filter_block_number_lte?: number | null;
    /**
     * Filter by block number less than
     */
    filter_block_number_lt?: number | null;
    /**
     * Filter by block hash
     */
    filter_block_hash?: string;
    /**
     * Filter by block timestamp
     */
    filter_block_timestamp?: number | null;
    /**
     * Filter by block timestamp greater than or equal to
     */
    filter_block_timestamp_gte?: number | null;
    /**
     * Filter by block timestamp greater than
     */
    filter_block_timestamp_gt?: number | null;
    /**
     * Filter by block timestamp less than or equal to
     */
    filter_block_timestamp_lte?: number | null;
    /**
     * Filter by block timestamp less than
     */
    filter_block_timestamp_lt?: number | null;
    /**
     * Field to sort results by
     */
    sort_by?: "block_number" | string;
    /**
     * Sort order (asc or desc)
     */
    sort_order?: "asc" | "desc";
    group_by?: Array<string | null> | (string | null) | unknown;
    aggregate?: Array<string | null> | (string | null) | unknown;
    /**
     * Filter by transaction index
     */
    filter_transaction_index?: number | null;
    /**
     * Filter by transaction index greater than or equal to
     */
    filter_transaction_index_gte?: number | null;
    /**
     * Filter by transaction index greater than
     */
    filter_transaction_index_gt?: number | null;
    /**
     * Filter by transaction index less than or equal to
     */
    filter_transaction_index_lte?: number | null;
    /**
     * Filter by transaction index less than
     */
    filter_transaction_index_lt?: number | null;
    /**
     * Enable ABI decoding of the transactions/events data
     */
    decode?: boolean | null;
    /**
     * Filter by transaction hash
     */
    filter_hash?: string;
    /**
     * Filter by from address
     */
    filter_from_address?: string;
    /**
     * Filter by value
     */
    filter_value?: number | null;
    /**
     * Filter by value greater than or equal to
     */
    filter_value_gte?: number | null;
    /**
     * Filter by value greater than
     */
    filter_value_gt?: number | null;
    /**
     * Filter by value less than or equal to
     */
    filter_value_lte?: number | null;
    /**
     * Filter by value less than
     */
    filter_value_lt?: number | null;
    /**
     * Filter by gas price
     */
    filter_gas_price?: number | null;
    /**
     * Filter by gas price greater than or equal to
     */
    filter_gas_price_gte?: number | null;
    /**
     * Filter by gas price greater than
     */
    filter_gas_price_gt?: number | null;
    /**
     * Filter by gas price less than or equal to
     */
    filter_gas_price_lte?: number | null;
    /**
     * Filter by gas price less than
     */
    filter_gas_price_lt?: number | null;
    /**
     * Filter by gas
     */
    filter_gas?: number | null;
    /**
     * Filter by gas greater than or equal to
     */
    filter_gas_gte?: number | null;
    /**
     * Filter by gas greater than
     */
    filter_gas_gt?: number | null;
    /**
     * Filter by gas less than or equal to
     */
    filter_gas_lte?: number | null;
    /**
     * Filter by gas less than
     */
    filter_gas_lt?: number | null;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/transactions/{contractAddress}/{signature}";
};

export type GetV1TransactionsByContractAddressBySignatureErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1TransactionsByContractAddressBySignatureError =
  GetV1TransactionsByContractAddressBySignatureErrors[keyof GetV1TransactionsByContractAddressBySignatureErrors];

export type GetV1TransactionsByContractAddressBySignatureResponses = {
  /**
   * Successful response
   */
  200: {
    data?: Array<{
      chain_id: number;
      block_number: string;
      block_hash: string;
      block_timestamp: string;
      hash: string;
      nonce: number;
      transaction_index: number;
      from_address: string;
      to_address: string;
      value: number;
      gas_price: number;
      gas: number;
      function_selector: string;
      data: string;
      max_fee_per_gas: number;
      max_priority_fee_per_gas: number;
      transaction_type: number;
      r: number;
      s: number;
      v: number;
      access_list_json?: string;
      contract_address?: string;
      gas_used?: number;
      cumulative_gas_used?: number;
      effective_gas_price?: number;
      blob_gas_used?: number;
      blob_gas_price?: number;
      logs_bloom?: string;
      status?: number;
      decoded?: {
        name: string;
        signature: string;
        inputs?: {};
      };
      /**
       * @deprecated
       */
      decodedData?: {
        name: string;
        signature: string;
        inputs?: {};
      };
    }>;
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1TransactionsByContractAddressBySignatureResponse =
  GetV1TransactionsByContractAddressBySignatureResponses[keyof GetV1TransactionsByContractAddressBySignatureResponses];

export type GetV1TokensTransfersTransactionByTransactionHashData = {
  body?: never;
  path: {
    transaction_hash: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * Whether to include sale details for NFT transfers
     */
    sales?: "true" | "false";
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
  };
  url: "/v1/tokens/transfers/transaction/{transaction_hash}";
};

export type GetV1TokensTransfersTransactionByTransactionHashErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    data: Array<{
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: "erc20";
      amount: string;
      chain_id: number;
      token_metadata?: {
        name?: string;
        symbol?: string;
        decimals?: number;
      };
    }>;
  };
};

export type GetV1TokensTransfersTransactionByTransactionHashError =
  GetV1TokensTransfersTransactionByTransactionHashErrors[keyof GetV1TokensTransfersTransactionByTransactionHashErrors];

export type GetV1TokensTransfersTransactionByTransactionHashResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: "erc20";
      amount: string;
      chain_id: number;
      token_metadata?: {
        name?: string;
        symbol?: string;
        decimals?: number;
      };
    }>;
  };
};

export type GetV1TokensTransfersTransactionByTransactionHashResponse =
  GetV1TokensTransfersTransactionByTransactionHashResponses[keyof GetV1TokensTransfersTransactionByTransactionHashResponses];

export type GetV1TokensTransfersByContractAddressData = {
  body?: never;
  path: {
    contract_address: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * Whether to include sale details for NFT transfers
     */
    sales?: "true" | "false";
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
  };
  url: "/v1/tokens/transfers/{contract_address}";
};

export type GetV1TokensTransfersByContractAddressErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    data: Array<{
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: "erc20";
      amount: string;
      chain_id: number;
      token_metadata?: {
        name?: string;
        symbol?: string;
        decimals?: number;
      };
    }>;
  };
};

export type GetV1TokensTransfersByContractAddressError =
  GetV1TokensTransfersByContractAddressErrors[keyof GetV1TokensTransfersByContractAddressErrors];

export type GetV1TokensTransfersByContractAddressResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: "erc20";
      amount: string;
      chain_id: number;
      token_metadata?: {
        name?: string;
        symbol?: string;
        decimals?: number;
      };
    }>;
  };
};

export type GetV1TokensTransfersByContractAddressResponse =
  GetV1TokensTransfersByContractAddressResponses[keyof GetV1TokensTransfersByContractAddressResponses];

export type GetV1TokensTransfersData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * Whether to include sale details for NFT transfers
     */
    sales?: "true" | "false";
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
    owner_address: string;
  };
  url: "/v1/tokens/transfers";
};

export type GetV1TokensTransfersErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    data: Array<{
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: "erc20";
      amount: string;
      chain_id: number;
      token_metadata?: {
        name?: string;
        symbol?: string;
        decimals?: number;
      };
    }>;
  };
};

export type GetV1TokensTransfersError =
  GetV1TokensTransfersErrors[keyof GetV1TokensTransfersErrors];

export type GetV1TokensTransfersResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: "erc20";
      amount: string;
      chain_id: number;
      token_metadata?: {
        name?: string;
        symbol?: string;
        decimals?: number;
      };
    }>;
  };
};

export type GetV1TokensTransfersResponse =
  GetV1TokensTransfersResponses[keyof GetV1TokensTransfersResponses];

export type GetV1TokensErc20ByOwnerAddressData = {
  body?: never;
  path: {
    ownerAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * Whether to include spam tokens
     */
    include_spam?: "true" | "false";
  };
  url: "/v1/tokens/erc20/{ownerAddress}";
};

export type GetV1TokensErc20ByOwnerAddressErrors = {
  /**
   * Bad request
   */
  400: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type GetV1TokensErc20ByOwnerAddressResponses = {
  /**
   * Successful response
   */
  200: {
    data: Array<{
      /**
       * The chain ID of a relevant entry
       */
      chain_id: number;
      token_address: string;
      balance: string;
      name?: string;
      symbol?: string;
      decimals?: number;
    }>;
  };
};

export type GetV1TokensErc20ByOwnerAddressResponse =
  GetV1TokensErc20ByOwnerAddressResponses[keyof GetV1TokensErc20ByOwnerAddressResponses];

export type GetV1TokensErc721ByOwnerAddressData = {
  body?: never;
  path: {
    ownerAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
  };
  url: "/v1/tokens/erc721/{ownerAddress}";
};

export type GetV1TokensErc721ByOwnerAddressErrors = {
  /**
   * Bad request
   */
  400: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type GetV1TokensErc721ByOwnerAddressResponses = {
  /**
   * Successful response
   */
  200: {
    data: Array<{
      /**
       * The chain ID of a relevant entry
       */
      chain_id: number;
      token_address: string;
      token_id: string;
      balance: string;
      name?: string;
      description?: string;
      image_url?: string;
      video_url?: string;
      animation_url?: string;
      background_color?: string;
      external_url?: string;
      status?: string;
      metadata_url?: string;
      owner_addresses?: Array<string>;
      extra_metadata?: {} & {
        attributes?:
          | Array<{
              trait_type: string;
              value: string | number;
              display_type?: string;
            }>
          | {};
        properties?: {};
      };
      collection?: {
        name?: string;
        description?: string;
        image_url?: string;
        banner_image_url?: string;
        featured_image_url?: string;
        external_link?: string;
      };
      contract?: {
        /**
         * The chain ID of a relevant entry
         */
        chain_id: number;
        address: string;
        name?: string;
        symbol?: string;
        type?: "erc721" | "erc1155";
      };
    }>;
  };
};

export type GetV1TokensErc721ByOwnerAddressResponse =
  GetV1TokensErc721ByOwnerAddressResponses[keyof GetV1TokensErc721ByOwnerAddressResponses];

export type GetV1TokensErc1155ByOwnerAddressData = {
  body?: never;
  path: {
    ownerAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
  };
  url: "/v1/tokens/erc1155/{ownerAddress}";
};

export type GetV1TokensErc1155ByOwnerAddressErrors = {
  /**
   * Bad request
   */
  400: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type GetV1TokensErc1155ByOwnerAddressResponses = {
  /**
   * Successful response
   */
  200: {
    data: Array<{
      /**
       * The chain ID of a relevant entry
       */
      chain_id: number;
      token_address: string;
      token_id: string;
      balance: string;
      name?: string;
      description?: string;
      image_url?: string;
      video_url?: string;
      animation_url?: string;
      background_color?: string;
      external_url?: string;
      status?: string;
      metadata_url?: string;
      owner_addresses?: Array<string>;
      extra_metadata?: {} & {
        attributes?:
          | Array<{
              trait_type: string;
              value: string | number;
              display_type?: string;
            }>
          | {};
        properties?: {};
      };
      collection?: {
        name?: string;
        description?: string;
        image_url?: string;
        banner_image_url?: string;
        featured_image_url?: string;
        external_link?: string;
      };
      contract?: {
        /**
         * The chain ID of a relevant entry
         */
        chain_id: number;
        address: string;
        name?: string;
        symbol?: string;
        type?: "erc721" | "erc1155";
      };
    }>;
  };
};

export type GetV1TokensErc1155ByOwnerAddressResponse =
  GetV1TokensErc1155ByOwnerAddressResponses[keyof GetV1TokensErc1155ByOwnerAddressResponses];

export type GetV1TokensPriceSupportedData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
  };
  url: "/v1/tokens/price/supported";
};

export type GetV1TokensPriceSupportedErrors = {
  /**
   * Bad request
   */
  400: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type GetV1TokensPriceSupportedResponses = {
  /**
   * Successful response
   */
  200: {
    data: Array<{
      /**
       * The chain ID of a relevant entry
       */
      chain_id: number;
      address: string;
      symbol?: string;
    }>;
  };
};

export type GetV1TokensPriceSupportedResponse =
  GetV1TokensPriceSupportedResponses[keyof GetV1TokensPriceSupportedResponses];

export type GetV1TokensPriceData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The address of the token to get the price for
     */
    address?: Array<string> | string;
    /**
     * The symbol of the token to get the price for
     */
    symbol?: Array<string> | (string | null) | unknown;
    /**
     * Timestamp in seconds or milliseconds
     */
    timestamp?: number;
  };
  url: "/v1/tokens/price";
};

export type GetV1TokensPriceErrors = {
  /**
   * Bad request
   */
  400: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type GetV1TokensPriceResponses = {
  /**
   * Successful response
   */
  200: {
    data: Array<{
      /**
       * The chain ID of a relevant entry
       */
      chain_id: number;
      address: string;
      symbol?: string;
      /**
       * Precise price in USD
       */
      price_usd: number;
      /**
       * Price in USD cents
       */
      price_usd_cents: number;
    }>;
  };
};

export type GetV1TokensPriceResponse =
  GetV1TokensPriceResponses[keyof GetV1TokensPriceResponses];

export type GetV1TokensLookupData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The symbol(s) of the token to lookup. You can specify multiple symbols, up to a maximum of 10.
     * Use repeated query parameters, e.g., `?symbol=ETH&symbol=USDC`.
     */
    symbol: Array<string> | string;
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
  };
  url: "/v1/tokens/lookup";
};

export type GetV1TokensLookupErrors = {
  /**
   * Bad request
   */
  400: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type GetV1TokensLookupResponses = {
  /**
   * Successful response
   */
  200: {
    data: Array<{
      /**
       * The chain ID of a relevant entry
       */
      chain_id: number;
      token_address: string;
      name?: string;
      symbol?: string;
      decimals?: number;
    }>;
  };
};

export type GetV1TokensLookupResponse =
  GetV1TokensLookupResponses[keyof GetV1TokensLookupResponses];

export type GetV1ResolveByInputData = {
  body?: never;
  path: {
    /**
     * Can be a block number, transaction or block hash, address, event signature or function selector
     */
    input: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
  };
  url: "/v1/resolve/{input}";
};

export type GetV1ResolveByInputErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1ResolveByInputError =
  GetV1ResolveByInputErrors[keyof GetV1ResolveByInputErrors];

export type GetV1ResolveByInputResponses = {
  /**
   * Successful response
   */
  200: {
    data?: {
      blocks?: Array<{
        chain_id: number;
        block_number: number;
        block_hash: string;
        parent_hash: string;
        block_timestamp: number;
        nonce: string;
        sha3_uncles: string;
        mix_hash: string;
        miner: string;
        state_root: string;
        transactions_root: string;
        receipts_root: string;
        logs_bloom: string;
        size: number;
        extra_data: string;
        difficulty: string;
        total_difficulty: string;
        transaction_count: number;
        gas_limit: number;
        gas_used: number;
        withdrawals_root: string;
        base_fee_per_gas: number;
      }>;
      transactions?: Array<{
        chain_id: number;
        block_number: string;
        block_hash: string;
        block_timestamp: string;
        hash: string;
        nonce: number;
        transaction_index: number;
        from_address: string;
        to_address: string;
        value: number;
        gas_price: number;
        gas: number;
        function_selector: string;
        data: string;
        max_fee_per_gas: number;
        max_priority_fee_per_gas: number;
        transaction_type: number;
        r: number;
        s: number;
        v: number;
        access_list_json?: string;
        contract_address?: string;
        gas_used?: number;
        cumulative_gas_used?: number;
        effective_gas_price?: number;
        blob_gas_used?: number;
        blob_gas_price?: number;
        logs_bloom?: string;
        status?: number;
      }>;
      events?: Array<{
        chain_id: number;
        block_number: string;
        block_hash: string;
        block_timestamp: string;
        transaction_hash: string;
        transaction_index: number;
        log_index: number;
        address: string;
        data: string;
        topics: Array<string>;
      }>;
      type:
        | "block"
        | "transaction"
        | "event_signature"
        | "function_signature"
        | "address"
        | "contract"
        | "unknown";
    };
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1ResolveByInputResponse =
  GetV1ResolveByInputResponses[keyof GetV1ResolveByInputResponses];

export type GetV1BlocksData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Filter by block number
     */
    filter_block_number?: number | null;
    /**
     * Filter by block number greater than or equal to
     */
    filter_block_number_gte?: number | null;
    /**
     * Filter by block number greater than
     */
    filter_block_number_gt?: number | null;
    /**
     * Filter by block number less than or equal to
     */
    filter_block_number_lte?: number | null;
    /**
     * Filter by block number less than
     */
    filter_block_number_lt?: number | null;
    /**
     * Filter by block timestamp
     */
    filter_block_timestamp?: number | null;
    /**
     * Filter by block timestamp greater than or equal to
     */
    filter_block_timestamp_gte?: number | null;
    /**
     * Filter by block timestamp greater than
     */
    filter_block_timestamp_gt?: number | null;
    /**
     * Filter by block timestamp less than or equal to
     */
    filter_block_timestamp_lte?: number | null;
    /**
     * Filter by block timestamp less than
     */
    filter_block_timestamp_lt?: number | null;
    /**
     * Field to sort results by
     */
    sort_by?: "block_number" | string;
    /**
     * Sort order (asc or desc)
     */
    sort_order?: "asc" | "desc";
    group_by?: Array<string | null> | (string | null) | unknown;
    aggregate?: Array<string | null> | (string | null) | unknown;
    /**
     * Filter by hash
     */
    filter_hash?: string;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/blocks";
};

export type GetV1BlocksErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1BlocksError = GetV1BlocksErrors[keyof GetV1BlocksErrors];

export type GetV1BlocksResponses = {
  /**
   * Successful response
   */
  200: {
    data?: Array<{
      chain_id: number;
      block_number: number;
      block_hash: string;
      parent_hash: string;
      block_timestamp: number;
      nonce: string;
      sha3_uncles: string;
      mix_hash: string;
      miner: string;
      state_root: string;
      transactions_root: string;
      receipts_root: string;
      logs_bloom: string;
      size: number;
      extra_data: string;
      difficulty: string;
      total_difficulty: string;
      transaction_count: number;
      gas_limit: number;
      gas_used: number;
      withdrawals_root: string;
      base_fee_per_gas: number;
    }>;
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1BlocksResponse =
  GetV1BlocksResponses[keyof GetV1BlocksResponses];

export type GetV1ContractsAbiByContractAddressData = {
  body?: never;
  path: {
    contractAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
  };
  url: "/v1/contracts/abi/{contractAddress}";
};

export type GetV1ContractsAbiByContractAddressErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1ContractsAbiByContractAddressError =
  GetV1ContractsAbiByContractAddressErrors[keyof GetV1ContractsAbiByContractAddressErrors];

export type GetV1ContractsAbiByContractAddressResponses = {
  /**
   * Success
   */
  200: {
    [key: string]: unknown;
  };
};

export type GetV1ContractsAbiByContractAddressResponse =
  GetV1ContractsAbiByContractAddressResponses[keyof GetV1ContractsAbiByContractAddressResponses];

export type GetV1ContractsMetadataByContractAddressData = {
  body?: never;
  path: {
    contractAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
  };
  url: "/v1/contracts/metadata/{contractAddress}";
};

export type GetV1ContractsMetadataByContractAddressErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1ContractsMetadataByContractAddressError =
  GetV1ContractsMetadataByContractAddressErrors[keyof GetV1ContractsMetadataByContractAddressErrors];

export type GetV1ContractsMetadataByContractAddressResponses = {
  /**
   * Success
   */
  200: {
    [key: string]: unknown;
  };
};

export type GetV1ContractsMetadataByContractAddressResponse =
  GetV1ContractsMetadataByContractAddressResponses[keyof GetV1ContractsMetadataByContractAddressResponses];

export type PostV1DecodeByContractAddressData = {
  body?: {
    transactions?: Array<{
      data: string;
    }>;
    logs?: Array<{
      data?: string;
      topics: Array<string>;
    }>;
  };
  path: {
    contractAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
  };
  url: "/v1/decode/{contractAddress}";
};

export type PostV1DecodeByContractAddressErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type PostV1DecodeByContractAddressError =
  PostV1DecodeByContractAddressErrors[keyof PostV1DecodeByContractAddressErrors];

export type PostV1DecodeByContractAddressResponses = {
  /**
   * Success
   */
  200: {
    data?: {
      transactions?: Array<{
        data: string;
        function_name?: string;
        args?: Array<unknown>;
      }>;
      logs?: Array<{
        data?: string;
        topics: Array<string>;
        event_name?: string;
        args?: Array<unknown>;
      }>;
    };
  };
};

export type PostV1DecodeByContractAddressResponse =
  PostV1DecodeByContractAddressResponses[keyof PostV1DecodeByContractAddressResponses];

export type GetV1NftsBalanceByOwnerAddressData = {
  body?: never;
  path: {
    ownerAddress: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * The types of NFTs to include in the response. Can be an empty array to include all types
     */
    token_types?: Array<"erc1155" | "erc721">;
  };
  url: "/v1/nfts/balance/{ownerAddress}";
};

export type GetV1NftsBalanceByOwnerAddressErrors = {
  /**
   * Bad request
   */
  400: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type GetV1NftsBalanceByOwnerAddressResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      /**
       * The chain ID of a relevant entry
       */
      chain_id: number;
      token_address: string;
      token_id: string;
      balance: string;
      name?: string;
      description?: string;
      image_url?: string;
      video_url?: string;
      animation_url?: string;
      background_color?: string;
      external_url?: string;
      status?: string;
      metadata_url?: string;
      owner_addresses?: Array<string>;
      extra_metadata?: {} & {
        attributes?:
          | Array<{
              trait_type: string;
              value: string | number;
              display_type?: string;
            }>
          | {};
        properties?: {};
      };
      collection?: {
        name?: string;
        description?: string;
        image_url?: string;
        banner_image_url?: string;
        featured_image_url?: string;
        external_link?: string;
      };
      contract?: {
        /**
         * The chain ID of a relevant entry
         */
        chain_id: number;
        address: string;
        name?: string;
        symbol?: string;
        type?: "erc721" | "erc1155";
      };
    }>;
  };
};

export type GetV1NftsBalanceByOwnerAddressResponse =
  GetV1NftsBalanceByOwnerAddressResponses[keyof GetV1NftsBalanceByOwnerAddressResponses];

export type GetV1NftsCollectionsByContractAddressData = {
  body?: never;
  path: {
    contract_address: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Whether to include stats for the collection
     */
    include_stats?: "true" | "false";
  };
  url: "/v1/nfts/collections/{contract_address}";
};

export type GetV1NftsCollectionsByContractAddressErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsCollectionsByContractAddressError =
  GetV1NftsCollectionsByContractAddressErrors[keyof GetV1NftsCollectionsByContractAddressErrors];

export type GetV1NftsCollectionsByContractAddressResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      name?: string;
      description?: string;
      image_url?: string;
      banner_image_url?: string;
      featured_image_url?: string;
      external_link?: string;
      stats?: {
        owner_count: number;
        token_count: number;
        mint_count: number;
        total_quantity: number;
      };
    }>;
  };
};

export type GetV1NftsCollectionsByContractAddressResponse =
  GetV1NftsCollectionsByContractAddressResponses[keyof GetV1NftsCollectionsByContractAddressResponses];

export type GetV1NftsData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    owner_address: string;
  };
  url: "/v1/nfts";
};

export type GetV1NftsErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsError = GetV1NftsErrors[keyof GetV1NftsErrors];

export type GetV1NftsResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      name?: string;
      description?: string;
      image_url?: string;
      video_url?: string;
      animation_url?: string;
      background_color?: string;
      external_url?: string;
      status?: string;
      metadata_url?: string;
      extra_metadata?: {} & {
        attributes?:
          | Array<{
              trait_type: string;
              value: string | number;
              display_type?: string;
            }>
          | {};
        properties?: {};
      };
      collection?: {
        name?: string;
        description?: string;
        image_url?: string;
        banner_image_url?: string;
        featured_image_url?: string;
        external_link?: string;
      };
      contract?: {
        /**
         * The chain ID of a relevant entry
         */
        chain_id: number;
        address: string;
        name?: string;
        symbol?: string;
        type?: "erc721" | "erc1155";
      };
      chain_id: number;
      contract_address: string;
      token_id: string;
      token_type: string;
      balance?: string;
    }>;
  };
};

export type GetV1NftsResponse = GetV1NftsResponses[keyof GetV1NftsResponses];

export type GetV1NftsOwnersByContractAddressData = {
  body?: never;
  path: {
    contract_address: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/nfts/owners/{contract_address}";
};

export type GetV1NftsOwnersByContractAddressErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsOwnersByContractAddressError =
  GetV1NftsOwnersByContractAddressErrors[keyof GetV1NftsOwnersByContractAddressErrors];

export type GetV1NftsOwnersByContractAddressResponses = {
  /**
   * Success
   */
  200: Array<{
    chain_id: string;
    owner_addresses: Array<string>;
  }>;
};

export type GetV1NftsOwnersByContractAddressResponse =
  GetV1NftsOwnersByContractAddressResponses[keyof GetV1NftsOwnersByContractAddressResponses];

export type GetV1NftsOwnersByContractAddressByTokenIdData = {
  body?: never;
  path: {
    contract_address: string;
    token_id: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/nfts/owners/{contract_address}/{token_id}";
};

export type GetV1NftsOwnersByContractAddressByTokenIdErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsOwnersByContractAddressByTokenIdError =
  GetV1NftsOwnersByContractAddressByTokenIdErrors[keyof GetV1NftsOwnersByContractAddressByTokenIdErrors];

export type GetV1NftsOwnersByContractAddressByTokenIdResponses = {
  /**
   * Success
   */
  200: Array<{
    chain_id: string;
    owner_addresses: Array<string>;
  }>;
};

export type GetV1NftsOwnersByContractAddressByTokenIdResponse =
  GetV1NftsOwnersByContractAddressByTokenIdResponses[keyof GetV1NftsOwnersByContractAddressByTokenIdResponses];

export type GetV1NftsTransfersData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * Whether to include sale details for NFT transfers
     */
    sales?: "true" | "false";
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
    owner_address: string;
  };
  url: "/v1/nfts/transfers";
};

export type GetV1NftsTransfersErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsTransfersError =
  GetV1NftsTransfersErrors[keyof GetV1NftsTransfersErrors];

export type GetV1NftsTransfersResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      token_id: string;
      chain_id: number;
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: string;
      amount: string;
      nft_metadata?: {
        name?: string;
        description?: string;
        image_url?: string;
        video_url?: string;
        animation_url?: string;
        background_color?: string;
        external_url?: string;
        status?: string;
        metadata_url?: string;
        owner_addresses?: Array<string>;
        extra_metadata?: {} & {
          attributes?:
            | Array<{
                trait_type: string;
                value: string | number;
                display_type?: string;
              }>
            | {};
          properties?: {};
        };
        collection?: {
          name?: string;
          description?: string;
          image_url?: string;
          banner_image_url?: string;
          featured_image_url?: string;
          external_link?: string;
        };
        contract?: {
          /**
           * The chain ID of a relevant entry
           */
          chain_id: number;
          address: string;
          name?: string;
          symbol?: string;
          type?: "erc721" | "erc1155";
        };
      };
      nft_sale?: {
        transaction_hash: string;
        items_sold: Array<{
          token_address: string;
          token_id: string;
          amount: string;
          token_type: string;
          from_address?: string;
          to_address?: string;
        }>;
        payment: Array<{
          token_address: string;
          token_id: string;
          amount: string;
          token_type: string;
          from_address?: string;
          to_address?: string;
        }>;
        marketplace_address: string;
        marketplace_name: string;
      };
    }>;
  };
};

export type GetV1NftsTransfersResponse =
  GetV1NftsTransfersResponses[keyof GetV1NftsTransfersResponses];

export type GetV1NftsTransfersTransactionByTransactionHashData = {
  body?: never;
  path: {
    transaction_hash: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * Whether to include sale details for NFT transfers
     */
    sales?: "true" | "false";
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
  };
  url: "/v1/nfts/transfers/transaction/{transaction_hash}";
};

export type GetV1NftsTransfersTransactionByTransactionHashErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsTransfersTransactionByTransactionHashError =
  GetV1NftsTransfersTransactionByTransactionHashErrors[keyof GetV1NftsTransfersTransactionByTransactionHashErrors];

export type GetV1NftsTransfersTransactionByTransactionHashResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      token_id: string;
      chain_id: number;
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: string;
      amount: string;
      nft_metadata?: {
        name?: string;
        description?: string;
        image_url?: string;
        video_url?: string;
        animation_url?: string;
        background_color?: string;
        external_url?: string;
        status?: string;
        metadata_url?: string;
        owner_addresses?: Array<string>;
        extra_metadata?: {} & {
          attributes?:
            | Array<{
                trait_type: string;
                value: string | number;
                display_type?: string;
              }>
            | {};
          properties?: {};
        };
        collection?: {
          name?: string;
          description?: string;
          image_url?: string;
          banner_image_url?: string;
          featured_image_url?: string;
          external_link?: string;
        };
        contract?: {
          /**
           * The chain ID of a relevant entry
           */
          chain_id: number;
          address: string;
          name?: string;
          symbol?: string;
          type?: "erc721" | "erc1155";
        };
      };
      nft_sale?: {
        transaction_hash: string;
        items_sold: Array<{
          token_address: string;
          token_id: string;
          amount: string;
          token_type: string;
          from_address?: string;
          to_address?: string;
        }>;
        payment: Array<{
          token_address: string;
          token_id: string;
          amount: string;
          token_type: string;
          from_address?: string;
          to_address?: string;
        }>;
        marketplace_address: string;
        marketplace_name: string;
      };
    }>;
  };
};

export type GetV1NftsTransfersTransactionByTransactionHashResponse =
  GetV1NftsTransfersTransactionByTransactionHashResponses[keyof GetV1NftsTransfersTransactionByTransactionHashResponses];

export type GetV1NftsTransfersByContractAddressData = {
  body?: never;
  path: {
    contract_address: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * Whether to include sale details for NFT transfers
     */
    sales?: "true" | "false";
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
  };
  url: "/v1/nfts/transfers/{contract_address}";
};

export type GetV1NftsTransfersByContractAddressErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsTransfersByContractAddressError =
  GetV1NftsTransfersByContractAddressErrors[keyof GetV1NftsTransfersByContractAddressErrors];

export type GetV1NftsTransfersByContractAddressResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      token_id: string;
      chain_id: number;
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: string;
      amount: string;
      nft_metadata?: {
        name?: string;
        description?: string;
        image_url?: string;
        video_url?: string;
        animation_url?: string;
        background_color?: string;
        external_url?: string;
        status?: string;
        metadata_url?: string;
        owner_addresses?: Array<string>;
        extra_metadata?: {} & {
          attributes?:
            | Array<{
                trait_type: string;
                value: string | number;
                display_type?: string;
              }>
            | {};
          properties?: {};
        };
        collection?: {
          name?: string;
          description?: string;
          image_url?: string;
          banner_image_url?: string;
          featured_image_url?: string;
          external_link?: string;
        };
        contract?: {
          /**
           * The chain ID of a relevant entry
           */
          chain_id: number;
          address: string;
          name?: string;
          symbol?: string;
          type?: "erc721" | "erc1155";
        };
      };
      nft_sale?: {
        transaction_hash: string;
        items_sold: Array<{
          token_address: string;
          token_id: string;
          amount: string;
          token_type: string;
          from_address?: string;
          to_address?: string;
        }>;
        payment: Array<{
          token_address: string;
          token_id: string;
          amount: string;
          token_type: string;
          from_address?: string;
          to_address?: string;
        }>;
        marketplace_address: string;
        marketplace_name: string;
      };
    }>;
  };
};

export type GetV1NftsTransfersByContractAddressResponse =
  GetV1NftsTransfersByContractAddressResponses[keyof GetV1NftsTransfersByContractAddressResponses];

export type GetV1NftsByContractAddressData = {
  body?: never;
  path: {
    contract_address: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
  };
  url: "/v1/nfts/{contract_address}";
};

export type GetV1NftsByContractAddressErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsByContractAddressError =
  GetV1NftsByContractAddressErrors[keyof GetV1NftsByContractAddressErrors];

export type GetV1NftsByContractAddressResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      name?: string;
      description?: string;
      image_url?: string;
      video_url?: string;
      animation_url?: string;
      background_color?: string;
      external_url?: string;
      status?: string;
      metadata_url?: string;
      owner_addresses: Array<string>;
      extra_metadata?: {} & {
        attributes?:
          | Array<{
              trait_type: string;
              value: string | number;
              display_type?: string;
            }>
          | {};
        properties?: {};
      };
      collection?: {
        name?: string;
        description?: string;
        image_url?: string;
        banner_image_url?: string;
        featured_image_url?: string;
        external_link?: string;
      };
      contract?: {
        /**
         * The chain ID of a relevant entry
         */
        chain_id: number;
        address: string;
        name?: string;
        symbol?: string;
        type?: "erc721" | "erc1155";
      };
      chain_id: number;
      contract_address: string;
      token_id: string;
      token_type: string;
      balance?: string;
    }>;
  };
};

export type GetV1NftsByContractAddressResponse =
  GetV1NftsByContractAddressResponses[keyof GetV1NftsByContractAddressResponses];

export type GetV1NftsTransfersByContractAddressByTokenIdData = {
  body?: never;
  path: {
    contract_address: string;
    token_id: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
    /**
     * Whether to include metadata for the tokens
     */
    metadata?: "true" | "false";
    /**
     * Whether to include sale details for NFT transfers
     */
    sales?: "true" | "false";
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
  };
  url: "/v1/nfts/transfers/{contract_address}/{token_id}";
};

export type GetV1NftsTransfersByContractAddressByTokenIdErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsTransfersByContractAddressByTokenIdError =
  GetV1NftsTransfersByContractAddressByTokenIdErrors[keyof GetV1NftsTransfersByContractAddressByTokenIdErrors];

export type GetV1NftsTransfersByContractAddressByTokenIdResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      token_id: string;
      chain_id: number;
      block_number: string;
      block_hash?: string;
      block_timestamp: string;
      transaction_hash: string;
      from_address: string;
      to_address: string;
      log_index: number;
      contract_address: string;
      transfer_type: "mint" | "sale" | "transfer";
      token_type: string;
      amount: string;
      nft_metadata?: {
        name?: string;
        description?: string;
        image_url?: string;
        video_url?: string;
        animation_url?: string;
        background_color?: string;
        external_url?: string;
        status?: string;
        metadata_url?: string;
        owner_addresses?: Array<string>;
        extra_metadata?: {} & {
          attributes?:
            | Array<{
                trait_type: string;
                value: string | number;
                display_type?: string;
              }>
            | {};
          properties?: {};
        };
        collection?: {
          name?: string;
          description?: string;
          image_url?: string;
          banner_image_url?: string;
          featured_image_url?: string;
          external_link?: string;
        };
        contract?: {
          /**
           * The chain ID of a relevant entry
           */
          chain_id: number;
          address: string;
          name?: string;
          symbol?: string;
          type?: "erc721" | "erc1155";
        };
      };
      nft_sale?: {
        transaction_hash: string;
        items_sold: Array<{
          token_address: string;
          token_id: string;
          amount: string;
          token_type: string;
          from_address?: string;
          to_address?: string;
        }>;
        payment: Array<{
          token_address: string;
          token_id: string;
          amount: string;
          token_type: string;
          from_address?: string;
          to_address?: string;
        }>;
        marketplace_address: string;
        marketplace_name: string;
      };
    }>;
  };
};

export type GetV1NftsTransfersByContractAddressByTokenIdResponse =
  GetV1NftsTransfersByContractAddressByTokenIdResponses[keyof GetV1NftsTransfersByContractAddressByTokenIdResponses];

export type GetV1NftsByContractAddressByTokenIdData = {
  body?: never;
  path: {
    contract_address: string;
    token_id: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Whether to include owner addresses in the response (only if NFT metadata is requested)
     */
    include_owners?: "true" | "false";
  };
  url: "/v1/nfts/{contract_address}/{token_id}";
};

export type GetV1NftsByContractAddressByTokenIdErrors = {
  /**
   * Not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsByContractAddressByTokenIdError =
  GetV1NftsByContractAddressByTokenIdErrors[keyof GetV1NftsByContractAddressByTokenIdErrors];

export type GetV1NftsByContractAddressByTokenIdResponses = {
  /**
   * Success
   */
  200: {
    data: Array<{
      name?: string;
      description?: string;
      image_url?: string;
      video_url?: string;
      animation_url?: string;
      background_color?: string;
      external_url?: string;
      status?: string;
      metadata_url?: string;
      owner_addresses: Array<string>;
      extra_metadata?: {} & {
        attributes?:
          | Array<{
              trait_type: string;
              value: string | number;
              display_type?: string;
            }>
          | {};
        properties?: {};
      };
      collection?: {
        name?: string;
        description?: string;
        image_url?: string;
        banner_image_url?: string;
        featured_image_url?: string;
        external_link?: string;
      };
      contract?: {
        /**
         * The chain ID of a relevant entry
         */
        chain_id: number;
        address: string;
        name?: string;
        symbol?: string;
        type?: "erc721" | "erc1155";
      };
      chain_id: number;
      contract_address: string;
      token_id: string;
      token_type: string;
      balance?: string;
    }>;
  };
};

export type GetV1NftsByContractAddressByTokenIdResponse =
  GetV1NftsByContractAddressByTokenIdResponses[keyof GetV1NftsByContractAddressByTokenIdResponses];

export type GetV1NftsMetadataRefreshByContractAddressData = {
  body?: never;
  path: {
    contract_address: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
  };
  url: "/v1/nfts/metadata/refresh/{contract_address}";
};

export type GetV1NftsMetadataRefreshByContractAddressErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsMetadataRefreshByContractAddressError =
  GetV1NftsMetadataRefreshByContractAddressErrors[keyof GetV1NftsMetadataRefreshByContractAddressErrors];

export type GetV1NftsMetadataRefreshByContractAddressResponses = {
  /**
   * Success
   */
  200: {
    data: {
      success: boolean;
      message: string;
    };
  };
};

export type GetV1NftsMetadataRefreshByContractAddressResponse =
  GetV1NftsMetadataRefreshByContractAddressResponses[keyof GetV1NftsMetadataRefreshByContractAddressResponses];

export type GetV1NftsMetadataRefreshByContractAddressByTokenIdData = {
  body?: never;
  path: {
    contract_address: string;
    token_id: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
  };
  url: "/v1/nfts/metadata/refresh/{contract_address}/{token_id}";
};

export type GetV1NftsMetadataRefreshByContractAddressByTokenIdErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1NftsMetadataRefreshByContractAddressByTokenIdError =
  GetV1NftsMetadataRefreshByContractAddressByTokenIdErrors[keyof GetV1NftsMetadataRefreshByContractAddressByTokenIdErrors];

export type GetV1NftsMetadataRefreshByContractAddressByTokenIdResponses = {
  /**
   * Success
   */
  200: {
    data: {
      success: boolean;
      message: string;
    };
  };
};

export type GetV1NftsMetadataRefreshByContractAddressByTokenIdResponse =
  GetV1NftsMetadataRefreshByContractAddressByTokenIdResponses[keyof GetV1NftsMetadataRefreshByContractAddressByTokenIdResponses];

export type GetV1WalletsByWalletAddressTransactionsData = {
  body?: never;
  path: {
    wallet_address: string;
  };
  query?: {
    /**
     * The chain ID(s) to request the data for. You can specify multiple chain IDs, up to a maximum of 5.
     * Use repeated query parameters, e.g., `?chain=20&chain=56`.
     * Optional, because a single chain can as well be specified as a subdomain
     */
    chain?: Array<number> | (number | null) | unknown;
    /**
     * Filter by block number
     */
    filter_block_number?: number | null;
    /**
     * Filter by block number greater than or equal to
     */
    filter_block_number_gte?: number | null;
    /**
     * Filter by block number greater than
     */
    filter_block_number_gt?: number | null;
    /**
     * Filter by block number less than or equal to
     */
    filter_block_number_lte?: number | null;
    /**
     * Filter by block number less than
     */
    filter_block_number_lt?: number | null;
    /**
     * Filter by block hash
     */
    filter_block_hash?: string;
    /**
     * Filter by block timestamp
     */
    filter_block_timestamp?: number | null;
    /**
     * Filter by block timestamp greater than or equal to
     */
    filter_block_timestamp_gte?: number | null;
    /**
     * Filter by block timestamp greater than
     */
    filter_block_timestamp_gt?: number | null;
    /**
     * Filter by block timestamp less than or equal to
     */
    filter_block_timestamp_lte?: number | null;
    /**
     * Filter by block timestamp less than
     */
    filter_block_timestamp_lt?: number | null;
    /**
     * Field to sort results by
     */
    sort_by?: "block_number" | string;
    /**
     * Sort order (asc or desc)
     */
    sort_order?: "asc" | "desc";
    group_by?: Array<string | null> | (string | null) | unknown;
    aggregate?: Array<string | null> | (string | null) | unknown;
    /**
     * Filter by transaction index
     */
    filter_transaction_index?: number | null;
    /**
     * Filter by transaction index greater than or equal to
     */
    filter_transaction_index_gte?: number | null;
    /**
     * Filter by transaction index greater than
     */
    filter_transaction_index_gt?: number | null;
    /**
     * Filter by transaction index less than or equal to
     */
    filter_transaction_index_lte?: number | null;
    /**
     * Filter by transaction index less than
     */
    filter_transaction_index_lt?: number | null;
    /**
     * Enable ABI decoding of the transactions/events data
     */
    decode?: boolean | null;
    /**
     * Filter by transaction hash
     */
    filter_hash?: string;
    /**
     * Filter by value
     */
    filter_value?: number | null;
    /**
     * Filter by value greater than or equal to
     */
    filter_value_gte?: number | null;
    /**
     * Filter by value greater than
     */
    filter_value_gt?: number | null;
    /**
     * Filter by value less than or equal to
     */
    filter_value_lte?: number | null;
    /**
     * Filter by value less than
     */
    filter_value_lt?: number | null;
    /**
     * Filter by gas price
     */
    filter_gas_price?: number | null;
    /**
     * Filter by gas price greater than or equal to
     */
    filter_gas_price_gte?: number | null;
    /**
     * Filter by gas price greater than
     */
    filter_gas_price_gt?: number | null;
    /**
     * Filter by gas price less than or equal to
     */
    filter_gas_price_lte?: number | null;
    /**
     * Filter by gas price less than
     */
    filter_gas_price_lt?: number | null;
    /**
     * Filter by gas
     */
    filter_gas?: number | null;
    /**
     * Filter by gas greater than or equal to
     */
    filter_gas_gte?: number | null;
    /**
     * Filter by gas greater than
     */
    filter_gas_gt?: number | null;
    /**
     * Filter by gas less than or equal to
     */
    filter_gas_lte?: number | null;
    /**
     * Filter by gas less than
     */
    filter_gas_lt?: number | null;
    /**
     * Filter by function selector
     */
    filter_function_selector?: string;
    /**
     * The number of items to return
     */
    limit?: number;
    page?: number | null;
  };
  url: "/v1/wallets/{wallet_address}/transactions";
};

export type GetV1WalletsByWalletAddressTransactionsErrors = {
  /**
   * Bad request
   */
  400: {
    error: string;
  };
  /**
   * Internal server error
   */
  500: {
    error: string;
  };
};

export type GetV1WalletsByWalletAddressTransactionsError =
  GetV1WalletsByWalletAddressTransactionsErrors[keyof GetV1WalletsByWalletAddressTransactionsErrors];

export type GetV1WalletsByWalletAddressTransactionsResponses = {
  /**
   * Successful response
   */
  200: {
    data?: Array<{
      chain_id: number;
      block_number: string;
      block_hash: string;
      block_timestamp: string;
      hash: string;
      nonce: number;
      transaction_index: number;
      from_address: string;
      to_address: string;
      value: number;
      gas_price: number;
      gas: number;
      function_selector: string;
      data: string;
      max_fee_per_gas: number;
      max_priority_fee_per_gas: number;
      transaction_type: number;
      r: number;
      s: number;
      v: number;
      access_list_json?: string;
      contract_address?: string;
      gas_used?: number;
      cumulative_gas_used?: number;
      effective_gas_price?: number;
      blob_gas_used?: number;
      blob_gas_price?: number;
      logs_bloom?: string;
      status?: number;
      decoded?: {
        name: string;
        signature: string;
        inputs?: {};
      };
      /**
       * @deprecated
       */
      decodedData?: {
        name: string;
        signature: string;
        inputs?: {};
      };
    }>;
    aggregations?: unknown;
    meta: {
      chain_ids: Array<number>;
      address?: string;
      signature?: string;
      page: number;
      limit_per_chain: number;
      total_items: number;
      total_pages: number;
    };
  };
};

export type GetV1WalletsByWalletAddressTransactionsResponse =
  GetV1WalletsByWalletAddressTransactionsResponses[keyof GetV1WalletsByWalletAddressTransactionsResponses];

export type ClientOptions = {
  baseUrl: "https://{chainId}.insight.thirdweb.com/" | (string & {});
};
