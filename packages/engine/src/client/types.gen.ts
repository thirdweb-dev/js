// This file is auto-generated by @hey-api/openapi-ts

export type TransactionsFilterValue = {
    field: 'id' | 'batchIndex' | 'from' | 'signerAddress' | 'smartAccountAddress' | 'chainId';
    values: Array<string>;
    operation: 'AND' | 'OR';
};

export type TransactionsFilterNested = {
    operation: 'AND' | 'OR';
    filters: Array<TransactionsFilterValue | TransactionsFilterNested>;
};

/**
 * This is the default execution option. If you do not specify an execution type, and only specify a "from" string, engine will automatically determine the most optimal options for you. If you would like to specify granular options about execution strategy choose one of the other `executionOptions` type and provide them.
 */
export type AutoExecutionOptions = {
    /**
     * This is the default, a `type` does not need to be specified
     */
    type?: 'auto';
    /**
     * The address of the account to send the transaction from. Can be the address of a smart account or an EOA.
     */
    from: string;
    /**
     * The idempotency key of the transaction. Transaction requests sent with the same idempotency key will be de-duplicated. If not provided, a randomUUID will be generated. This is also used as the ID of a queued/stored transaction.
     */
    idempotencyKey?: string;
    /**
     * The chain id of the transaction
     */
    chainId: string;
};

export type AaExecutionOptions = {
    type: 'ERC4337';
    /**
     * The address of the engine managed account which can send transactions from your smart account
     */
    signerAddress: string;
    sponsorGas?: boolean;
    /**
     * The address of the smart account factory. Defaults to thirdweb default v0.7 Account Factory. Only specify this if you are using a custom account factory.
     */
    factoryAddress?: string;
    /**
     * The address of the entrypoint contract. Defaults to the v0.7 entrypoint for the chain. Only specify this if you want to specify a different version.
     */
    entrypointAddress?: string;
    /**
     * The address of the smart account to send the transaction from. Either specify this, or the salt. If not specified, the inferred smart account will be with null salt. If both are specified, the salt will be ignored.
     */
    smartAccountAddress?: string;
    /**
     * The salt of the smart account to send the transaction from. Only specify this if you want to specify a custom salt. If omitted, and smart account address is not provided, the inferred smart account will be with null salt. If a smart account address is provided, the salt will be ignored.
     */
    accountSalt?: string;
    /**
     * The idempotency key of the transaction. Transaction requests sent with the same idempotency key will be de-duplicated. If not provided, a randomUUID will be generated. This is also used as the ID of a queued/stored transaction.
     */
    idempotencyKey?: string;
    /**
     * The chain id of the transaction
     */
    chainId: string;
};

/**
 * Uses zkSync native AA for execution. This type of execution is only available on zkSync chains.
 */
export type AaZksyncExecutionOptions = {
    type: 'zksync';
    /**
     * The EOA address of the account to send the zksync native AA transaction from.
     */
    accountAddress: string;
    sponsorGas?: boolean;
    /**
     * The idempotency key of the transaction. Transaction requests sent with the same idempotency key will be de-duplicated. If not provided, a randomUUID will be generated. This is also used as the ID of a queued/stored transaction.
     */
    idempotencyKey?: string;
    /**
     * The chain id of the transaction
     */
    chainId: string;
};

export type PostWriteContractData = {
    body?: {
        /**
         * Use a specific execution type and provide options to configure engine's execution strategy. The default execution option is `auto`, (doesn't need to be specified) which will automatically determine the most optimal options for you. If you would like to specify granular options about execution strategy choose one of the other `executionOptions` type and provide them.
         */
        executionOptions: AutoExecutionOptions | AaExecutionOptions | AaZksyncExecutionOptions;
        params: Array<{
            /**
             * The function to call on the contract
             */
            method: string;
            /**
             * The parameters to pass to the function
             */
            params: Array<unknown>;
            /**
             * The contract address to call
             */
            contractAddress: string;
            /**
             * The ABI of the contract
             */
            abi?: Array<unknown>;
            /**
             * The value to send with the transaction
             */
            value?: string;
        }>;
    };
    headers?: {
        /**
         * Vault Access Token used to access your EOA
         */
        'x-vault-access-token'?: string;
    };
    path?: never;
    query?: never;
    url: '/write/contract';
};

export type PostWriteContractResponses = {
    /**
     * Transaction sent successfully
     */
    200: {
        result: Array<{
            id: string;
            batchIndex: number;
            chainId: string;
            from: string | null;
            transactionParams: (string | number | boolean | null) | {} | Array<unknown>;
            transactionHash: string | null;
            confirmedAt: string | null;
            confirmedAtBlockNumber: string | null;
            enrichedData: (string | number | boolean | null) | {} | Array<unknown>;
            executionParams: (string | number | boolean | null) | {} | Array<unknown>;
            executionResult: (string | number | boolean | null) | {} | Array<unknown> | null;
            createdAt: string;
            errorMessage: string | null;
            cancelledAt: string | null;
        }>;
    };
    /**
     * Transaction queued successfully
     */
    202: {
        result: {
            transactions: Array<{
                id: string;
                batchIndex: number;
                chainId: string;
                from: string | null;
                transactionParams: (string | number | boolean | null) | {} | Array<unknown>;
                transactionHash: string | null;
                confirmedAt: string | null;
                confirmedAtBlockNumber: string | null;
                enrichedData: (string | number | boolean | null) | {} | Array<unknown>;
                executionParams: (string | number | boolean | null) | {} | Array<unknown>;
                executionResult: (string | number | boolean | null) | {} | Array<unknown> | null;
                createdAt: string;
                errorMessage: string | null;
                cancelledAt: string | null;
            }>;
        };
    };
};

export type PostWriteContractResponse = PostWriteContractResponses[keyof PostWriteContractResponses];

export type PostWriteTransactionData = {
    body?: {
        /**
         * Use a specific execution type and provide options to configure engine's execution strategy. The default execution option is `auto`, (doesn't need to be specified) which will automatically determine the most optimal options for you. If you would like to specify granular options about execution strategy choose one of the other `executionOptions` type and provide them.
         */
        executionOptions: AutoExecutionOptions | AaExecutionOptions | AaZksyncExecutionOptions;
        params: Array<{
            /**
             * The address of the contract to send the transaction to
             */
            to?: string;
            /**
             * The data of the transaction
             */
            data?: string;
            /**
             * The value of the transaction
             */
            value?: string;
        }>;
    };
    headers?: {
        /**
         * Vault Access Token used to access your EOA
         */
        'x-vault-access-token'?: string;
    };
    path?: never;
    query?: never;
    url: '/write/transaction';
};

export type PostWriteTransactionResponses = {
    /**
     * Transaction sent successfully
     */
    200: {
        result: Array<{
            id: string;
            batchIndex: number;
            chainId: string;
            from: string | null;
            transactionParams: (string | number | boolean | null) | {} | Array<unknown>;
            transactionHash: string | null;
            confirmedAt: string | null;
            confirmedAtBlockNumber: string | null;
            enrichedData: (string | number | boolean | null) | {} | Array<unknown>;
            executionParams: (string | number | boolean | null) | {} | Array<unknown>;
            executionResult: (string | number | boolean | null) | {} | Array<unknown> | null;
            createdAt: string;
            errorMessage: string | null;
            cancelledAt: string | null;
        }>;
    };
    /**
     * Transaction queued successfully
     */
    202: {
        result: {
            transactions: Array<{
                id: string;
                batchIndex: number;
                chainId: string;
                from: string | null;
                transactionParams: (string | number | boolean | null) | {} | Array<unknown>;
                transactionHash: string | null;
                confirmedAt: string | null;
                confirmedAtBlockNumber: string | null;
                enrichedData: (string | number | boolean | null) | {} | Array<unknown>;
                executionParams: (string | number | boolean | null) | {} | Array<unknown>;
                executionResult: (string | number | boolean | null) | {} | Array<unknown> | null;
                createdAt: string;
                errorMessage: string | null;
                cancelledAt: string | null;
            }>;
        };
    };
};

export type PostWriteTransactionResponse = PostWriteTransactionResponses[keyof PostWriteTransactionResponses];

export type PostSignTransactionData = {
    body?: {
        /**
         * Use a specific execution type and provide options to configure engine's execution strategy. The default execution option is `auto`, (doesn't need to be specified) which will automatically determine the most optimal options for you. If you would like to specify granular options about execution strategy choose one of the other `executionOptions` type and provide them.
         */
        executionOptions: AutoExecutionOptions | AaExecutionOptions | AaZksyncExecutionOptions;
        params: Array<{
            /**
             * The recipient address
             */
            to: string;
            /**
             * The transaction data as hex
             */
            data?: string;
            /**
             * The value to send with the transaction
             */
            value?: string;
            /**
             * Transaction nonce
             */
            nonce?: number;
            /**
             * Gas limit
             */
            gasLimit?: string;
            /**
             * Gas price (for legacy transactions)
             */
            gasPrice?: string;
            /**
             * Max fee per gas (for EIP-1559)
             */
            maxFeePerGas?: string;
            /**
             * Max priority fee per gas (for EIP-1559)
             */
            maxPriorityFeePerGas?: string;
            /**
             * Access list for EIP-2930 and later transactions
             */
            accessList?: Array<{
                /**
                 * EVM address in hex format
                 */
                address: string;
                storageKeys: Array<string>;
            }>;
            /**
             * Max fee per blob gas (for EIP-4844)
             */
            maxFeePerBlobGas?: string;
            /**
             * Blob versioned hashes (for EIP-4844)
             */
            blobVersionedHashes?: Array<string>;
            /**
             * Authorization list (for EIP-7702)
             */
            authorizationList?: Array<{
                /**
                 * Authorization address
                 */
                address: string;
                /**
                 * r value of the signature
                 */
                r: string;
                /**
                 * s value of the signature
                 */
                s: string;
                /**
                 * v value of the signature
                 */
                v?: number | string;
                /**
                 * yParity value (0 or 1)
                 */
                yParity: number;
                /**
                 * Authorization nonce
                 */
                nonce: string;
                /**
                 * Authorization chainId
                 */
                chainId: number;
            }>;
        }>;
    };
    headers?: {
        /**
         * Vault Access Token used to access your EOA
         */
        'x-vault-access-token'?: string;
    };
    path?: never;
    query?: never;
    url: '/sign/transaction';
};

export type PostSignTransactionResponses = {
    /**
     * OK
     */
    200: {
        result: {
            results: Array<{
                success: true;
                result: {
                    /**
                     * The resulting signature
                     */
                    signature: string;
                    /**
                     * Optional signed data
                     */
                    signedData?: string;
                };
            } | {
                success: false;
                /**
                 * Standardized error object
                 */
                error: {
                    kind: string;
                    code: string;
                    status: number;
                    message?: string;
                    /**
                     * EVM address in hex format
                     */
                    address?: string;
                    chainId?: string;
                };
            }>;
        };
    };
};

export type PostSignTransactionResponse = PostSignTransactionResponses[keyof PostSignTransactionResponses];

export type PostSignMessageData = {
    body?: {
        /**
         * Use a specific execution type and provide options to configure engine's execution strategy. The default execution option is `auto`, (doesn't need to be specified) which will automatically determine the most optimal options for you. If you would like to specify granular options about execution strategy choose one of the other `executionOptions` type and provide them.
         */
        executionOptions: AutoExecutionOptions | AaExecutionOptions | AaZksyncExecutionOptions;
        params: Array<{
            /**
             * The message to sign
             */
            message: string;
            /**
             * Format of the message (text or hex)
             */
            messageFormat?: 'text' | 'hex';
        }>;
    };
    headers?: {
        /**
         * Vault Access Token used to access your EOA
         */
        'x-vault-access-token'?: string;
    };
    path?: never;
    query?: never;
    url: '/sign/message';
};

export type PostSignMessageResponses = {
    /**
     * OK
     */
    200: {
        result: {
            results: Array<{
                success: true;
                result: {
                    /**
                     * The resulting signature
                     */
                    signature: string;
                    /**
                     * Optional signed data
                     */
                    signedData?: string;
                };
            } | {
                success: false;
                /**
                 * Standardized error object
                 */
                error: {
                    kind: string;
                    code: string;
                    status: number;
                    message?: string;
                    /**
                     * EVM address in hex format
                     */
                    address?: string;
                    chainId?: string;
                };
            }>;
        };
    };
};

export type PostSignMessageResponse = PostSignMessageResponses[keyof PostSignMessageResponses];

export type PostSignTypedDataData = {
    body?: {
        /**
         * Use a specific execution type and provide options to configure engine's execution strategy. The default execution option is `auto`, (doesn't need to be specified) which will automatically determine the most optimal options for you. If you would like to specify granular options about execution strategy choose one of the other `executionOptions` type and provide them.
         */
        executionOptions: AutoExecutionOptions | AaExecutionOptions | AaZksyncExecutionOptions;
        params: Array<{
            domain: {
                chainId?: number | number;
                name?: string;
                salt?: string;
                verifyingContract?: string;
                version?: string;
            };
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            primaryType: string;
            message: {};
        }>;
    };
    headers?: {
        /**
         * Vault Access Token used to access your EOA
         */
        'x-vault-access-token'?: string;
    };
    path?: never;
    query?: never;
    url: '/sign/typed-data';
};

export type PostSignTypedDataResponses = {
    /**
     * OK
     */
    200: {
        result: {
            results: Array<{
                success: true;
                result: {
                    /**
                     * The resulting signature
                     */
                    signature: string;
                    /**
                     * Optional signed data
                     */
                    signedData?: string;
                };
            } | {
                success: false;
                /**
                 * Standardized error object
                 */
                error: {
                    kind: string;
                    code: string;
                    status: number;
                    message?: string;
                    /**
                     * EVM address in hex format
                     */
                    address?: string;
                    chainId?: string;
                };
            }>;
        };
    };
};

export type PostSignTypedDataResponse = PostSignTypedDataResponses[keyof PostSignTypedDataResponses];

export type PostReadContractData = {
    body?: {
        readOptions: {
            /**
             * Optional multicall address, defaults to the default multicall3 address for the chain
             */
            multicallAddress?: string;
            /**
             * The chain id of the transaction
             */
            chainId: string;
            /**
             * EVM address in hex format
             */
            from?: string;
        };
        params: Array<{
            /**
             * The function to call on the contract
             */
            method: string;
            /**
             * The parameters to pass to the function
             */
            params: Array<unknown>;
            /**
             * The contract address to call
             */
            contractAddress: string;
            /**
             * The ABI of the contract
             */
            abi?: Array<unknown>;
        }>;
    };
    path?: never;
    query?: never;
    url: '/read/contract';
};

export type PostReadContractResponses = {
    /**
     * OK
     */
    200: {
        result: {
            results: Array<{
                success: boolean;
                result?: null;
            }>;
        };
    };
};

export type PostReadContractResponse = PostReadContractResponses[keyof PostReadContractResponses];

export type PostReadBalanceData = {
    body?: {
        /**
         * The chain ID to query the balance on.
         */
        chainId: string;
        /**
         * The EVM address to get the native balance for.
         */
        address: string;
    };
    path?: never;
    query?: never;
    url: '/read/balance';
};

export type PostReadBalanceErrors = {
    /**
     * Bad Request - Invalid input
     */
    400: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PostReadBalanceResponses = {
    /**
     * OK - Balance fetched successfully.
     */
    200: {
        result: {
            /**
             * The native balance of the address as a stringified integer.
             */
            balance: string;
        };
    };
};

export type PostReadBalanceResponse = PostReadBalanceResponses[keyof PostReadBalanceResponses];

export type PostEncodeContractData = {
    body?: {
        encodeOptions: {
            /**
             * The chain id of the transaction
             */
            chainId: string;
        };
        params: Array<{
            /**
             * The function to call on the contract
             */
            method: string;
            /**
             * The parameters to pass to the function
             */
            params: Array<unknown>;
            /**
             * The contract address to call
             */
            contractAddress: string;
            /**
             * The ABI of the contract
             */
            abi?: Array<unknown>;
            /**
             * The value to send with the transaction
             */
            value?: string;
        }>;
    };
    path?: never;
    query?: never;
    url: '/encode/contract';
};

export type PostEncodeContractResponses = {
    /**
     * OK
     */
    200: {
        result: {
            results: Array<{
                success: true;
                result: {
                    /**
                     * EVM address in hex format
                     */
                    to: string;
                    data: string;
                    /**
                     * A string representing an bigint response, safe to parse with BigInt
                     */
                    value: string;
                };
            } | {
                success: false;
                /**
                 * Standardized error object
                 */
                error: {
                    kind: string;
                    code: string;
                    status: number;
                    message?: string;
                    /**
                     * EVM address in hex format
                     */
                    address?: string;
                    chainId?: string;
                };
            }>;
        };
    };
};

export type PostEncodeContractResponse = PostEncodeContractResponses[keyof PostEncodeContractResponses];

export type SearchTransactionsData = {
    body?: {
        page?: number;
        limit?: number;
        filters?: Array<TransactionsFilterValue | TransactionsFilterNested>;
        filtersOperation?: 'AND' | 'OR';
        sortBy?: 'createdAt' | 'confirmedAt';
        sortDirection?: 'asc' | 'desc';
    };
    path?: never;
    query?: never;
    url: '/project/transactions/search';
};

export type SearchTransactionsResponses = {
    /**
     * Transactions
     */
    200: {
        result: {
            transactions: Array<{
                id: string;
                batchIndex: number;
                chainId: string;
                from: string | null;
                transactionParams: (string | number | boolean | null) | {} | Array<unknown>;
                transactionHash: string | null;
                confirmedAt: string | null;
                confirmedAtBlockNumber: string | null;
                enrichedData: (string | number | boolean | null) | {} | Array<unknown>;
                executionParams: (string | number | boolean | null) | {} | Array<unknown>;
                executionResult: (string | number | boolean | null) | {} | Array<unknown> | null;
                createdAt: string;
                errorMessage: string | null;
                cancelledAt: string | null;
            }>;
            pagination: {
                totalCount: number;
                page: number;
                limit: number;
            };
        };
    };
};

export type SearchTransactionsResponse = SearchTransactionsResponses[keyof SearchTransactionsResponses];

export type GetTransactionAnalyticsData = {
    body?: {
        startDate: string;
        endDate: string;
        resolution: 'hour' | 'day' | 'week' | 'month';
        filters?: Array<TransactionsFilterValue | TransactionsFilterNested>;
        filtersOperation?: 'AND' | 'OR';
    };
    path?: never;
    query?: never;
    url: '/project/transactions/analytics';
};

export type GetTransactionAnalyticsResponses = {
    /**
     * Transaction Analytics
     */
    200: {
        result: {
            analytics: Array<{
                timeBucket: string;
                chainId: string;
                count: number;
            }>;
            metadata: {
                resolution: 'hour' | 'day' | 'week' | 'month';
                startDate: string;
                endDate: string;
            };
        };
    };
};

export type GetTransactionAnalyticsResponse = GetTransactionAnalyticsResponses[keyof GetTransactionAnalyticsResponses];

export type GetTransactionAnalyticsSummaryData = {
    body?: {
        startDate?: string;
        endDate?: string;
        filters?: Array<TransactionsFilterValue | TransactionsFilterNested>;
        filtersOperation?: 'AND' | 'OR';
    };
    path?: never;
    query?: never;
    url: '/project/transactions/analytics-summary';
};

export type GetTransactionAnalyticsSummaryErrors = {
    /**
     * Bad Request (e.g., invalid date format, filter depth exceeded)
     */
    400: unknown;
    /**
     * Internal Server Error (e.g., database error)
     */
    500: unknown;
};

export type GetTransactionAnalyticsSummaryResponses = {
    /**
     * Transaction Analytics Summary
     */
    200: {
        result: {
            summary: {
                /**
                 * Total number of transactions matching the criteria.
                 */
                totalCount: number;
                /**
                 * Sum of actualGasCost (in wei) for all matching transactions, as a string.
                 */
                totalGasCostWei: string;
                /**
                 * Sum of actualGasUsed (gas units) for all matching transactions, as a string.
                 */
                totalGasUnitsUsed: string;
            };
            metadata: {
                startDate?: string;
                endDate?: string;
            };
        };
    };
};

export type GetTransactionAnalyticsSummaryResponse = GetTransactionAnalyticsSummaryResponses[keyof GetTransactionAnalyticsSummaryResponses];

export type ClientOptions = {
    baseUrl: 'https://engine-cloud-dev-l8wt.chainsaw-dev.zeet.app' | (string & {});
};