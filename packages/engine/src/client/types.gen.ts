// This file is auto-generated by @hey-api/openapi-ts

export type TransactionsFilterValue = {
	field:
		| "id"
		| "batchIndex"
		| "from"
		| "signerAddress"
		| "smartAccountAddress"
		| "chainId";
	values: Array<string>;
	operation: "AND" | "OR";
};

export type TransactionsFilterNested = {
	operation: "AND" | "OR";
	filters: Array<TransactionsFilterValue | TransactionsFilterNested>;
};

/**
 * EVM Address
 * Used to represent an EVM address. This is a string of length 42 with a `0x` prefix. Non-checksummed addresses are also supported, but will be converted to checksummed.
 */
export type AddressDef = string;

/**
 * Auto Determine Execution
 * This is the default execution option.
 * If you do not specify an execution type, and only specify a "from" string,
 * engine will automatically determine the most optimal options for you.
 * If you would like to specify granular options about execution strategy
 * choose one of the other executionOptions type and provide them.
 */
export type AutoExecutionOptions = {
	/**
	 * The identifier of the entity to send the transaction from.
	 * Automatically picks best execution strategy based on the identifier.
	 * - If EOA address, execution uses EIP7702 based smart-wallet execution
	 * - If 7702 not supported on chain, falls back to smart-contract wallet (ERC4337) with default smart account for this EOA (v0.7)
	 * - UNLESS this is a zk-chain, in which case, zk-sync native-aa is used
	 */
	from: string;
};

export type BaseExecutionOptions = {
	chainId: number;
	idempotencyKey?: string;
};

/**
 * Result of a single contract encode operation
 *
 * Each result can either be successful (containing the encoded transaction data)
 * or failed (containing detailed error information).
 */
export type BatchResultItemEncodeResultSuccessItemEngineError =
	| {
			/**
			 * Successful result from a contract encode operation
			 */
			result: {
				/**
				 * The contract address that would be called
				 */
				target: string;
				/**
				 * The encoded function call data
				 *
				 * This includes the function selector and encoded parameters,
				 * ready to be used in a transaction
				 */
				callData: string;
				/**
				 * The 4-byte function selector (first 4 bytes of call_data)
				 */
				functionSelector: string;
				/**
				 * The name of the function being called
				 */
				functionName: string;
			};
	  }
	| {
			error:
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "RPC_ERROR";
				  }
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "PAYMASTER_ERROR";
				  }
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "BUNDLER_ERROR";
				  }
				| {
						message: string;
						type: "VAULT_ERROR";
				  }
				| {
						error: IawError;
						type: "IAW_ERROR";
				  }
				| {
						message: string;
						type: "RPC_CONFIG_ERROR";
				  }
				| {
						contractAddress?: null | AddressDef;
						/**
						 * Chain ID
						 */
						chainId: number;
						/**
						 * Human-readable error message
						 */
						message: string;
						/**
						 * Specific error kind
						 */
						kind: ContractInteractionErrorKind;
						type: "CONTRACT_INTERACTION_ERROR";
				  }
				| {
						message: string;
						type: "VALIDATION_ERROR";
				  }
				| {
						message: string;
						type: "THIRDWEB_ERROR";
				  }
				| {
						message: string;
						type: "INTERNAL_ERROR";
				  };
	  };

/**
 * Result of a single contract encode operation
 *
 * Each result can either be successful (containing the encoded transaction data)
 * or failed (containing detailed error information).
 */
export type BatchResultItemReadResultSuccessItemEngineError =
	| {
			/**
			 * Successful result from a contract read operation
			 */
			result: Value;
	  }
	| {
			error:
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "RPC_ERROR";
				  }
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "PAYMASTER_ERROR";
				  }
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "BUNDLER_ERROR";
				  }
				| {
						message: string;
						type: "VAULT_ERROR";
				  }
				| {
						error: IawError;
						type: "IAW_ERROR";
				  }
				| {
						message: string;
						type: "RPC_CONFIG_ERROR";
				  }
				| {
						contractAddress?: null | AddressDef;
						/**
						 * Chain ID
						 */
						chainId: number;
						/**
						 * Human-readable error message
						 */
						message: string;
						/**
						 * Specific error kind
						 */
						kind: ContractInteractionErrorKind;
						type: "CONTRACT_INTERACTION_ERROR";
				  }
				| {
						message: string;
						type: "VALIDATION_ERROR";
				  }
				| {
						message: string;
						type: "THIRDWEB_ERROR";
				  }
				| {
						message: string;
						type: "INTERNAL_ERROR";
				  };
	  };

/**
 * Result of a single contract encode operation
 *
 * Each result can either be successful (containing the encoded transaction data)
 * or failed (containing detailed error information).
 */
export type BatchResultItemSignResultDataEngineError =
	| {
			/**
			 * Data returned from successful signing
			 */
			result: {
				/**
				 * The resulting signature
				 */
				signature: string;
				/**
				 * The data that was signed (stringified typed data)
				 */
				signedData: string;
			};
	  }
	| {
			error:
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "RPC_ERROR";
				  }
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "PAYMASTER_ERROR";
				  }
				| {
						/**
						 * Detailed RPC error information
						 */
						chain_id: number;
						rpc_url: string;
						message: string;
						kind: RpcErrorKind;
						type: "BUNDLER_ERROR";
				  }
				| {
						message: string;
						type: "VAULT_ERROR";
				  }
				| {
						error: IawError;
						type: "IAW_ERROR";
				  }
				| {
						message: string;
						type: "RPC_CONFIG_ERROR";
				  }
				| {
						contractAddress?: null | AddressDef;
						/**
						 * Chain ID
						 */
						chainId: number;
						/**
						 * Human-readable error message
						 */
						message: string;
						/**
						 * Specific error kind
						 */
						kind: ContractInteractionErrorKind;
						type: "CONTRACT_INTERACTION_ERROR";
				  }
				| {
						message: string;
						type: "VALIDATION_ERROR";
				  }
				| {
						message: string;
						type: "THIRDWEB_ERROR";
				  }
				| {
						message: string;
						type: "INTERNAL_ERROR";
				  };
	  };

/**
 * Collection of results from multiple contract encode operations
 */
export type BatchResultsEncodeResultSuccessItem = {
	/**
	 * Array of results, one for each input contract call
	 */
	result: Array<BatchResultItemEncodeResultSuccessItemEngineError>;
};

/**
 * Collection of results from multiple contract encode operations
 */
export type BatchResultsReadResultSuccessItem = {
	/**
	 * Array of results, one for each input contract call
	 */
	result: Array<BatchResultItemReadResultSuccessItemEngineError>;
};

/**
 * Collection of results from multiple contract encode operations
 */
export type BatchResultsSignResultData = {
	/**
	 * Array of results, one for each input contract call
	 */
	result: Array<BatchResultItemSignResultDataEngineError>;
};

/**
 * Bytes
 * Used to represent "bytes". This is a 0x prefixed hex string.
 */
export type BytesDef = string;

export type CancelResult =
	| "CANCELLED_IMMEDIATELY"
	| "CANCELLATION_PENDING"
	| {
			CANNOT_CANCEL: {
				reason: string;
			};
	  }
	| "NOT_FOUND";

/**
 * Represents a contract function call with parameters
 *
 * This is the base type used by all contract interaction endpoints.
 * It supports both function names and full function signatures, with
 * automatic ABI resolution when needed.
 */
export type ContractCall = {
	/**
	 * The address of the smart contract to call
	 */
	contractAddress: AddressDef;
	/**
	 * The function to call - can be a name like "transfer" or full signature like "transfer(address,uint256)"
	 */
	method: string;
	/**
	 * Array of parameters to pass to the function
	 */
	params: Array<Value>;
	abi?: null | Value;
};

/**
 * A serializable contract interaction error type
 */
export type ContractInteractionErrorKind =
	| {
			functionName: string;
			type: "UNKNOWN_FUNCTION";
	  }
	| {
			functionSelector: string;
			type: "UNKNOWN_SELECTOR";
	  }
	| {
			type: "NOT_A_DEPLOYMENT_TRANSACTION";
	  }
	| {
			type: "CONTRACT_NOT_DEPLOYED";
	  }
	| {
			function: string;
			message: string;
			type: "ZERO_DATA";
	  }
	| {
			message: string;
			type: "ABI_ERROR";
	  }
	| {
			message: string;
			type: "TRANSPORT_ERROR";
	  }
	| {
			message: string;
			type: "PENDING_TRANSACTION_ERROR";
	  }
	| {
			message: string;
			type: "PREPARATION_FAILED";
	  }
	| {
			message: string;
			type: "MULTICALL_EXECUTION_FAILED";
	  }
	| {
			message: string;
			type: "RESULT_DECODING_FAILED";
	  }
	| {
			message: string;
			type: "PARAMETER_VALIDATION_FAILED";
	  }
	| {
			message: string;
			type: "FUNCTION_RESOLUTION_FAILED";
	  };

/**
 * A contract function call with optional ETH value to send
 */
export type ContractWrite = ContractCall & {
	value?: null | U256Def;
};

/**
 * EIP-7702 Execution Options
 */
export type Eip7702ExecutionOptions = {
	/**
	 * The EOA address that will sign the EIP-7702 transaction
	 */
	from: AddressDef;
};

export type EmptyIdempotencySetResponse = {
	queueName: string;
	message: string;
};

/**
 * Options for encoding contract function calls
 */
export type EncodeOptions = {
	/**
	 * The blockchain network ID to encode for
	 *
	 * This is used to fetch the correct ABI if not provided inline
	 */
	chainId: string;
};

/**
 * Request to encode contract function calls
 */
export type EncodeRequest = {
	/**
	 * Configuration options for encoding
	 */
	encodeOptions: EncodeOptions;
	/**
	 * List of contract function calls to encode
	 *
	 * Each call will be encoded to its raw transaction data
	 */
	params: Array<ContractCall>;
};

/**
 * Successful result from a contract encode operation
 */
export type EncodeResultSuccessItem = {
	/**
	 * The contract address that would be called
	 */
	target: string;
	/**
	 * The encoded function call data
	 *
	 * This includes the function selector and encoded parameters,
	 * ready to be used in a transaction
	 */
	callData: string;
	/**
	 * The 4-byte function selector (first 4 bytes of call_data)
	 */
	functionSelector: string;
	/**
	 * The name of the function being called
	 */
	functionName: string;
};

export type EntrypointAndFactoryDetailsDeserHelper = {
	entrypointAddress?: null | AddressDef;
	entrypointVersion?: null | EntrypointVersion;
	factoryAddress?: null | AddressDef;
};

export type EntrypointVersion = "0.6" | "0.7";

/**
 * ### EOA Execution Options
 * This struct configures EOA (Externally Owned Account) direct execution.
 *
 * EOA execution sends transactions directly from an EOA address without
 * smart contract abstraction. This is the most basic form of transaction
 * execution and is suitable for simple transfers and contract interactions.
 *
 * ### Use Cases
 * - Direct ETH transfers
 * - Simple contract interactions
 * - Gas-efficient transactions
 * - When smart account features are not needed
 *
 * ### Features
 * - Direct transaction execution from EOA
 * - Automatic nonce management
 * - Gas price optimization
 * - Transaction confirmation tracking
 * - Retry and recovery mechanisms
 * - Support for EIP-1559, EIP-2930, and Legacy transactions
 * - Support for EIP-7702 delegated transactions
 */
export type EoaExecutionOptions = {
	/**
	 * The EOA address to send transactions from
	 * This account must have sufficient balance to pay for gas and transaction value
	 */
	from: AddressDef;
};

/**
 * EOA signing options
 */
export type EoaSigningOptions = {
	/**
	 * The EOA address to sign with
	 */
	from: AddressDef;
	chainId?: null | U64;
};

/**
 * ### ERC-4337 Execution Options
 * This struct allows flexible configuration of ERC-4337 execution options,
 * with intelligent defaults and inferences based on provided values.
 *
 * ### Field Inference
 * When fields are omitted, the system uses the following inference rules:
 *
 * 1. Version Inference:
 * - If `entrypointVersion` is provided, it's used directly
 * - Otherwise, tries to infer from `entrypointAddress` (if provided)
 * - If that fails, tries to infer from `factoryAddress` (if provided)
 * - Defaults to version 0.7 if no inference is possible
 *
 * 2. Entrypoint Address Inference:
 * - If provided explicitly, it's used as-is
 * - Otherwise, uses the default address corresponding to the inferred version:
 * - V0.6: 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789
 * - V0.7: 0x0576a174D229E3cFA37253523E645A78A0C91B57
 *
 * 3. Factory Address Inference:
 * - If provided explicitly, it's used as-is
 * - Otherwise, uses the default factory corresponding to the inferred version:
 * - V0.6: 0x85e23b94e7F5E9cC1fF78BCe78cfb15B81f0DF00 [DEFAULT_FACTORY_ADDRESS_V0_6]
 * - V0.7: 0x4bE0ddfebcA9A5A4a617dee4DeCe99E7c862dceb [DEFAULT_FACTORY_ADDRESS_V0_7]
 *
 * 4. Account Salt:
 * - If provided explicitly, it's used as-is
 * - Otherwise, defaults to "0x" (commonly used as the defauult "null" salt for smart accounts)
 *
 * 5. Smart Account Address:
 * - If provided explicitly, it's used as-is
 * - Otherwise, it's read from the smart account factory
 *
 * All optional fields can be omitted for a minimal configuration using version 0.7 defaults.
 *
 * The most minimal usage only requires `signerAddress` + `chainId`
 */
export type Erc4337ExecutionOptions = EntrypointAndFactoryDetailsDeserHelper & {
	signerAddress: AddressDef;
	accountSalt?: string;
	smartAccountAddress?: null | AddressDef;
};

/**
 * ### ERC4337 (Smart Account) Signing Options
 * This struct allows flexible configuration of ERC-4337 signing options,
 * with intelligent defaults and inferences based on provided values.
 *
 * ### Field Inference
 * When fields are omitted, the system uses the following inference rules:
 *
 * 1. Version Inference:
 * - If `entrypointVersion` is provided, it's used directly
 * - Otherwise, tries to infer from `entrypointAddress` (if provided)
 * - If that fails, tries to infer from `factoryAddress` (if provided)
 * - Defaults to version 0.7 if no inference is possible
 *
 * 2. Entrypoint Address Inference:
 * - If provided explicitly, it's used as-is
 * - Otherwise, uses the default address corresponding to the inferred version:
 * - V0.6: 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789
 * - V0.7: 0x0576a174D229E3cFA37253523E645A78A0C91B57
 *
 * 3. Factory Address Inference:
 * - If provided explicitly, it's used as-is
 * - Otherwise, uses the default factory corresponding to the inferred version:
 * - V0.6: 0x85e23b94e7F5E9cC1fF78BCe78cfb15B81f0DF00 [DEFAULT_FACTORY_ADDRESS_V0_6]
 * - V0.7: 0x4bE0ddfebcA9A5A4a617dee4DeCe99E7c862dceb [DEFAULT_FACTORY_ADDRESS_V0_7]
 *
 * 4. Account Salt:
 * - If provided explicitly, it's used as-is
 * - Otherwise, defaults to "0x" (commonly used as the defauult "null" salt for smart accounts)
 *
 * 5. Smart Account Address:
 * - If provided explicitly, it's used as-is
 * - Otherwise, it's read from the smart account factory
 *
 * All optional fields can be omitted for a minimal configuration using version 0.7 defaults.
 *
 * The most minimal usage only requires `signerAddress` + `chainId`
 */
export type Erc4337SigningOptions = EntrypointAndFactoryDetailsDeserHelper & {
	smartAccountAddress?: null | AddressDef;
	/**
	 * The EOA that controls the smart account
	 */
	signerAddress: AddressDef;
	/**
	 * Account salt for deterministic addresses
	 */
	accountSalt?: string;
	/**
	 * Chain ID for smart account operations
	 */
	chainId: U64;
};

/**
 * This is the exposed API for execution options
 * Base and specific execution options are both flattened together
 */
export type ExecutionOptions = BaseExecutionOptions & SpecificExecutionOptions;

/**
 * Error types for IAW operations
 */
export type IawError =
	| {
			message: string;
			type: "API_ERROR";
	  }
	| {
			message: string;
			type: "SERIALIZATION_ERROR";
	  }
	| {
			error: SerializableReqwestError;
			type: "NETWORK_ERROR";
	  }
	| {
			type: "AUTH_ERROR";
	  }
	| (ThirdwebError & {
			type: "THIRDWEB_ERROR";
	  })
	| {
			type: "UNEXPECTED_ERROR";
	  }
	| (UserOpError & {
			type: "USER_OP_ERROR";
	  });

/**
 * ### InnerTransaction
 * This is the actual encoded inner transaction data that will be sent to the blockchain.
 */
export type InnerTransaction = (null | TransactionTypeData) & {
	to?: null | AddressDef;
	data?: BytesDef;
	value?: U256Def;
	/**
	 * Gas limit for the transaction
	 * If not provided, engine will estimate the gas limit
	 */
	gasLimit?: number | null;
};

export type MessageFormatDef = "text" | "hex";

/**
 * Individual message to sign
 */
export type MessageInput = {
	/**
	 * The message to sign
	 */
	message: string;
	/**
	 * Message format (text or hex)
	 */
	format?: MessageFormatDef;
};

export type MulticallDocType = boolean | AddressDef;

/**
 * # QueuedTransaction
 * Response for any request that queues one or more transactions
 */
export type QueuedTransaction = {
	/**
	 * The idempotency key this transaction was queued with
	 * Either autogenerated UUID or provided by the user
	 * Multiple queued transactions can have the same idempotency key
	 * A "blockchain transaction" is uniquely identified by the idempotency key + batchIndex
	 */
	id: string;
	/**
	 * When multiple transactions are sent together via an execution mode that doesn't support atomic batching,
	 * each transaction will have a unique batchIndex but the same id (idempotency key)
	 * This maintains the relationship between different atomically sent blockchain transactions that were queued together
	 */
	batchIndex: number;
	/**
	 * The fully resolved execution options for this transaction, derived from the resolution of user specific execution options
	 * Difference in naming is to prevent confusion when response executionParams contain different values than the request executionOptions
	 */
	executionParams: ExecutionOptions;
	/**
	 * This is the actual encoded inner transaction data that will be sent to the blockchain.
	 * For non-atomic transactions, this will be a single transaction
	 * For atomic transactions, this will be a list of transactions, because they were atomically sent together
	 */
	transactionParams: Array<InnerTransaction>;
};

export type QueuedTransactionsResponse = {
	transactions: Array<QueuedTransaction>;
};

/**
 * Options for reading from smart contracts
 */
export type ReadOptions = {
	/**
	 * The blockchain network ID to read from
	 */
	chainId: number;
	multicall?: null | MulticallDocType;
	from?: null | AddressDef;
};

/**
 * Request to read from multiple smart contracts
 */
export type ReadRequest = {
	/**
	 * Configuration options for the read operation
	 */
	readOptions: ReadOptions;
	/**
	 * List of contract function calls to execute
	 *
	 * All calls will be batched together using Multicall3 for efficiency
	 */
	params: Array<ContractCall>;
};

/**
 * Successful result from a contract read operation
 */
export type ReadResultSuccessItem = Value;

export type RpcErrorKind =
	| (RpcErrorResponse & {
			type: "ERROR_RESP";
	  })
	| {
			type: "NULL_RESP";
	  }
	| {
			message: string;
			type: "UNSUPPORTED_FEATURE";
	  }
	| {
			message: string;
			type: "INTERNAL_ERROR";
	  }
	| {
			/**
			 * The underlying serde_json error.
			 */
			message: string;
			type: "SER_ERROR";
	  }
	| {
			/**
			 * The underlying serde_json error.
			 */
			message: string;
			/**
			 * For deser errors, the text that failed to deserialize.
			 */
			text: string;
			type: "DESER_ERROR";
	  }
	| {
			status: number;
			body: string;
			type: "TRANSPORT_HTTP_ERROR";
	  }
	| {
			message: string;
			type: "OTHER_TRANSPORT_ERROR";
	  };

export type RpcErrorResponse = {
	/**
	 * The error code.
	 */
	code: number;
	/**
	 * The error message (if any).
	 */
	message: string;
	/**
	 * The error data (if any).
	 */
	data?: string | null;
};

/**
 * Incoming transaction request, parsed into InnerTransaction
 * Exposed API will have varying `params` but will all parse into InnerTransaction before execution
 */
export type SendTransactionRequest = {
	executionOptions: ExecutionOptions;
	params: Array<InnerTransaction>;
	webhookOptions?: Array<WebhookOptions>;
};

export type SerializableReqwestError =
	| {
			Builder: {
				message: string;
				url?: string | null;
			};
	  }
	| {
			Request: {
				message: string;
				url?: string | null;
			};
	  }
	| {
			Timeout: {
				message: string;
				url?: string | null;
			};
	  }
	| {
			Connect: {
				message: string;
				url?: string | null;
			};
	  }
	| {
			Redirect: {
				message: string;
				url?: string | null;
			};
	  }
	| {
			ClientError: {
				status: number;
				message: string;
				url?: string | null;
			};
	  }
	| {
			ServerError: {
				status: number;
				message: string;
				url?: string | null;
			};
	  }
	| {
			Body: {
				message: string;
				url?: string | null;
			};
	  }
	| {
			Decode: {
				message: string;
				url?: string | null;
			};
	  }
	| {
			Upgrade: {
				message: string;
				url?: string | null;
			};
	  }
	| {
			Unknown: {
				message: string;
				url?: string | null;
			};
	  };

/**
 * Request to sign messages
 */
export type SignMessageRequest = {
	/**
	 * Configuration options for signing
	 */
	signingOptions: SigningOptions;
	/**
	 * List of messages to sign
	 */
	params: Array<MessageInput>;
};

/**
 * Data returned from successful signing
 */
export type SignResultData = {
	/**
	 * The resulting signature
	 */
	signature: string;
	/**
	 * The data that was signed (stringified typed data)
	 */
	signedData: string;
};

/**
 * Request to sign typed data
 */
export type SignTypedDataRequest = {
	/**
	 * Configuration options for signing
	 */
	signingOptions: SigningOptions;
	/**
	 * List of typed data to sign
	 */
	params: Array<TypedDataDef>;
};

/**
 * EIP-7702 Signed Authorization
 * EIP-7702 Signed Authorization structure for OpenAPI schema
 * Contains an authorization plus the cryptographic signature
 */
export type SignedAuthorizationSchema = {
	/**
	 * The chain ID of the authorization
	 * Must match the chain where the transaction will be executed
	 */
	chainId: U256Def;
	/**
	 * The smart contract address to delegate to
	 * This contract will be able to execute logic on behalf of the EOA
	 */
	address: AddressDef;
	/**
	 * The nonce for the authorization
	 * Must be the current nonce of the authorizing account
	 */
	nonce: number;
	/**
	 * Signature parity value (0 or 1)
	 * Used for ECDSA signature recovery
	 */
	yParity: number;
	/**
	 * Signature r value
	 * First component of the ECDSA signature
	 */
	r: U256Def;
	/**
	 * Signature s value
	 * Second component of the ECDSA signature
	 */
	s: U256Def;
};

/**
 * Configuration options for signing operations
 */
export type SigningOptions =
	| (EoaSigningOptions & {
			type: "EOA";
	  })
	| (Erc4337SigningOptions & {
			type: "ERC4337";
	  })
	| {
			type: "auto";
			/**
			 * The address to sign from
			 */
			from: string;
			/**
			 * The chain ID for the signing operation
			 */
			chainId: number;
	  };

/**
 * Execution Option Variants
 * All supported specific execution options are contained here
 */
export type SpecificExecutionOptions =
	| (AutoExecutionOptions & {
			type: "auto";
	  })
	| (Erc4337ExecutionOptions & {
			type: "ERC4337";
	  })
	| (EoaExecutionOptions & {
			type: "EOA";
	  })
	| (Eip7702ExecutionOptions & {
			type: "EIP7702";
	  });

export type SuccessResponseEmptyIdempotencySetResponse = {
	result: {
		queueName: string;
		message: string;
	};
};

export type SuccessResponseQueuedTransactionsResponse = {
	result: {
		transactions: Array<QueuedTransaction>;
	};
};

export type ThirdwebError =
	| {
			error: ThirdwebSerializationError;
			type: "SERIALIZATION_ERROR";
	  }
	| {
			value: string;
			message: string;
			type: "URL_PARSE_ERROR";
	  }
	| {
			message: string;
			type: "HTTP_CLIENT_BACKEND_ERROR";
	  }
	| {
			error: SerializableReqwestError;
			type: "HTTP_ERROR";
	  };

export type ThirdwebSerializationError = {
	HeaderValue: {
		value: string;
	};
};

/**
 * EIP-1559 Specific Transaction Data
 * EIP-1559 transaction configuration
 * Uses base fee + priority fee model for more predictable gas pricing
 */
export type Transaction1559Data = {
	/**
	 * Maximum fee per gas willing to pay (in wei)
	 * This is the total fee cap including base fee and priority fee
	 */
	maxFeePerGas?: number | null;
	/**
	 * Maximum priority fee per gas willing to pay (in wei)
	 * This is the tip paid to validators for transaction inclusion
	 */
	maxPriorityFeePerGas?: number | null;
};

/**
 * EIP-7702 Specific Transaction Data
 * EIP-7702 transaction configuration
 * Allows delegation of EOA to smart contract logic temporarily
 */
export type Transaction7702Data = {
	/**
	 * List of signed authorizations for contract delegation
	 * Each authorization allows the EOA to temporarily delegate to a smart contract
	 */
	authorizationList?: Array<SignedAuthorizationSchema> | null;
	/**
	 * Maximum fee per gas willing to pay (in wei)
	 * This is the total fee cap including base fee and priority fee
	 */
	maxFeePerGas?: number | null;
	/**
	 * Maximum priority fee per gas willing to pay (in wei)
	 * This is the tip paid to validators for transaction inclusion
	 */
	maxPriorityFeePerGas?: number | null;
};

export type TransactionCancelResponse = {
	transactionId: string;
	result: CancelResult;
};

/**
 * Legacy Specific Transaction Data
 * Legacy transaction configuration
 * Uses simple gas price model (pre-EIP-1559)
 */
export type TransactionLegacyData = {
	/**
	 * Gas price willing to pay (in wei)
	 * This is the total price per unit of gas for legacy transactions
	 */
	gasPrice?: number | null;
};

/**
 * Transaction Type Specific Data
 */
export type TransactionTypeData =
	| Transaction7702Data
	| Transaction1559Data
	| TransactionLegacyData;

export type TypedDataDef = {
	/**
	 * Signing domain metadata. The signing domain is the intended context for
	 * the signature (e.g. the dapp, protocol, etc. that it's intended for).
	 * This data is used to construct the domain separator of the message.
	 */
	domain: TypedDataDomainDef;
	/**
	 * The custom types used by this message.
	 */
	types: unknown;
	/**
	 * The type of the message.
	 */
	primaryType: string;
	/**
	 * The message to be signed.
	 */
	message: unknown;
};

export type TypedDataDomainDef = {
	name?: string | null;
	/**
	 * The current major version of the signing domain. Signatures from
	 * different versions are not compatible.
	 */
	version?: string | null;
	chainId?: null | U256Def;
	verifyingContract?: null | AddressDef;
	/**
	 * A disambiguating salt for the protocol. This can be used as a domain
	 * separator of last resort.
	 */
	salt?: string | null;
};

/**
 * U256
 * Used to represent a 256-bit unsigned integer. Engine can parse these from any valid encoding of the Ethereum "quantity" format.
 */
export type U256Def = string;

/**
 * Error type for UserOp operations
 */
export type UserOpError = {
	type: "UNEXPECTED_ERROR";
};

export type Value = unknown;

export type WebhookOptions = {
	url: string;
	secret?: string | null;
	/**
	 * Custom metadata provided by the user to be included in webhook notifications.
	 * Limited to 4KB (4096 bytes) to prevent abuse.
	 */
	userMetadata?: string | null;
};

/**
 * Request to execute write transactions to smart contracts
 */
export type WriteContractRequest = {
	/**
	 * Execution configuration including chain, account, and transaction options
	 */
	executionOptions: ExecutionOptions;
	/**
	 * List of contract function calls to execute
	 *
	 * All calls will be executed in a single transaction if possible,
	 * or as separate transactions if atomic batching is not supported
	 */
	params: Array<ContractWrite>;
	webhookOptions?: Array<WebhookOptions>;
};

export type U64 = number;

export type WriteContractData = {
	/**
	 * Write contract request
	 */
	body: WriteContractRequest;
	headers?: {
		/**
		 * Vault access token
		 */
		"x-vault-access-token"?: string | null;
	};
	path?: never;
	query?: never;
	url: "/v1/write/contract";
};

export type WriteContractResponses = {
	/**
	 * Transaction(s) queued successfully
	 */
	202: SuccessResponseQueuedTransactionsResponse;
};

export type WriteContractResponse =
	WriteContractResponses[keyof WriteContractResponses];

export type SendTransactionData = {
	/**
	 * Transaction request
	 */
	body: SendTransactionRequest;
	headers?: {
		/**
		 * Vault access token
		 */
		"x-vault-access-token"?: string | null;
	};
	path?: never;
	query?: never;
	url: "/v1/write/transaction";
};

export type SendTransactionResponses = {
	/**
	 * Transaction queued successfully
	 */
	202: SuccessResponseQueuedTransactionsResponse;
};

export type SendTransactionResponse =
	SendTransactionResponses[keyof SendTransactionResponses];

export type SignMessageData = {
	/**
	 * Sign message request
	 */
	body: SignMessageRequest;
	headers?: {
		/**
		 * Vault access token
		 */
		"x-vault-access-token"?: string | null;
	};
	path?: never;
	query?: never;
	url: "/v1/sign/message";
};

export type SignMessageResponses = {
	/**
	 * Successfully signed messages
	 */
	200: BatchResultsSignResultData;
};

export type SignMessageResponse =
	SignMessageResponses[keyof SignMessageResponses];

export type SignTypedDataData = {
	/**
	 * Sign typed data request
	 */
	body: SignTypedDataRequest;
	headers?: {
		/**
		 * Vault access token
		 */
		"x-vault-access-token"?: string | null;
	};
	path?: never;
	query?: never;
	url: "/v1/sign/typed-data";
};

export type SignTypedDataResponses = {
	/**
	 * Successfully signed typed data
	 */
	200: BatchResultsSignResultData;
};

export type SignTypedDataResponse =
	SignTypedDataResponses[keyof SignTypedDataResponses];

export type ReadContractData = {
	/**
	 * Read contract request
	 */
	body: ReadRequest;
	path?: never;
	query?: never;
	url: "/v1/read/contract";
};

export type ReadContractResponses = {
	/**
	 * Successfully read contract data
	 */
	200: BatchResultsReadResultSuccessItem;
};

export type ReadContractResponse =
	ReadContractResponses[keyof ReadContractResponses];

export type EncodeContractData = {
	/**
	 * Encode contract request
	 */
	body: EncodeRequest;
	path?: never;
	query?: never;
	url: "/v1/encode/contract";
};

export type EncodeContractResponses = {
	/**
	 * Successfully encoded contract calls
	 */
	200: BatchResultsEncodeResultSuccessItem;
};

export type EncodeContractResponse =
	EncodeContractResponses[keyof EncodeContractResponses];

export type CancelTransactionData = {
	body?: never;
	path: {
		/**
		 * Transaction ID to cancel
		 */
		id: string;
	};
	query?: never;
	url: "/v1/transactions/{id}/cancel";
};

export type CancelTransactionResponses = {
	/**
	 * Transaction cancellation result
	 */
	200: TransactionCancelResponse;
};

export type CancelTransactionResponse =
	CancelTransactionResponses[keyof CancelTransactionResponses];

export type ListAccountsData = {
	body?: never;
	path?: never;
	query?: {
		page?: number;
		limit?: number;
	};
	url: "/v1/accounts";
};

export type ListAccountsResponses = {
	/**
	 * Accounts retrieved successfully
	 */
	200: {
		result: {
			accounts: Array<{
				/**
				 * EVM address in hex format
				 */
				address: string;
				label?: string;
				createdAt: string;
				/**
				 * The predicted smart account address for use with the default thirdweb v0.7 AccountFactory
				 */
				smartAccountAddress?: string;
			}>;
			pagination: {
				totalCount: number;
				page: number;
				limit: number;
			};
		};
	};
};

export type ListAccountsResponse =
	ListAccountsResponses[keyof ListAccountsResponses];

export type CreateAccountData = {
	body?: {
		label: string;
	};
	headers?: {
		/**
		 * Vault Access Token used to access your EOA
		 */
		"x-vault-access-token"?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/accounts";
};

export type CreateAccountResponses = {
	/**
	 * Account created successfully
	 */
	201: {
		result: {
			/**
			 * EVM address in hex format
			 */
			address: string;
			label?: string;
			createdAt: string;
			/**
			 * The predicted smart account address for use with the default thirdweb v0.7 AccountFactory
			 */
			smartAccountAddress?: string;
		};
	};
};

export type CreateAccountResponse =
	CreateAccountResponses[keyof CreateAccountResponses];

export type GetTransactionsData = {
	body?: never;
	path?: never;
	query?: {
		page?: number;
		limit?: number;
		id?: string;
		batchIndex?: number;
		/**
		 * EVM address in hex format
		 */
		from?: string;
		/**
		 * EVM address in hex format
		 */
		signerAddress?: string;
		status?: "QUEUED" | "SUBMITTED" | "CONFIRMED" | "FAILED";
		sortBy?: "createdAt" | "confirmedAt";
		sortDirection?: "asc" | "desc";
	};
	url: "/v1/transactions";
};

export type GetTransactionsResponses = {
	/**
	 * Transactions
	 */
	200: {
		result: {
			transactions: Array<{
				id: string;
				batchIndex: number;
				clientId: string;
				chainId: string;
				from: string | null;
				transactionParams:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>;
				transactionHash: string | null;
				confirmedAt: string | null;
				confirmedAtBlockNumber: string | null;
				enrichedData:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>;
				executionParams:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>;
				executionResult:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>
					| null;
				createdAt: string;
				errorMessage: string | null;
				cancelledAt: string | null;
			}>;
			pagination: {
				totalCount: number;
				page: number;
				limit: number;
			};
		};
	};
};

export type GetTransactionsResponse =
	GetTransactionsResponses[keyof GetTransactionsResponses];

export type GetTransactionAnalyticsData = {
	body?: {
		startDate: string;
		endDate: string;
		resolution: "hour" | "day" | "week" | "month";
		filters?: Array<TransactionsFilterValue | TransactionsFilterNested>;
		filtersOperation?: "AND" | "OR";
	};
	path?: never;
	query?: never;
	url: "/v1/transactions/analytics";
};

export type GetTransactionAnalyticsResponses = {
	/**
	 * Transaction Analytics
	 */
	200: {
		result: {
			analytics: Array<{
				timeBucket: string;
				chainId: string;
				count: number;
			}>;
			metadata: {
				resolution: "hour" | "day" | "week" | "month";
				startDate: string;
				endDate: string;
			};
		};
	};
};

export type GetTransactionAnalyticsResponse =
	GetTransactionAnalyticsResponses[keyof GetTransactionAnalyticsResponses];

export type GetTransactionAnalyticsSummaryData = {
	body?: {
		startDate?: string;
		endDate?: string;
		filters?: Array<TransactionsFilterValue | TransactionsFilterNested>;
		filtersOperation?: "AND" | "OR";
	};
	path?: never;
	query?: never;
	url: "/v1/transactions/analytics-summary";
};

export type GetTransactionAnalyticsSummaryErrors = {
	/**
	 * Bad Request (e.g., invalid date format, filter depth exceeded)
	 */
	400: unknown;
	/**
	 * Internal Server Error (e.g., database error)
	 */
	500: unknown;
};

export type GetTransactionAnalyticsSummaryResponses = {
	/**
	 * Transaction Analytics Summary
	 */
	200: {
		result: {
			summary: {
				/**
				 * Total number of transactions matching the criteria.
				 */
				totalCount: number;
				/**
				 * Sum of actualGasCost (in wei) for all matching transactions, as a string.
				 */
				totalGasCostWei: string;
				/**
				 * Sum of actualGasUsed (gas units) for all matching transactions, as a string.
				 */
				totalGasUnitsUsed: string;
			};
			metadata: {
				startDate?: string;
				endDate?: string;
			};
		};
	};
};

export type GetTransactionAnalyticsSummaryResponse =
	GetTransactionAnalyticsSummaryResponses[keyof GetTransactionAnalyticsSummaryResponses];

export type SearchTransactionsData = {
	body?: {
		page?: number;
		limit?: number;
		filters?: Array<TransactionsFilterValue | TransactionsFilterNested>;
		filtersOperation?: "AND" | "OR";
		sortBy?: "createdAt" | "confirmedAt";
		sortDirection?: "asc" | "desc";
	};
	path?: never;
	query?: never;
	url: "/v1/transactions/search";
};

export type SearchTransactionsResponses = {
	/**
	 * Transactions
	 */
	200: {
		result: {
			transactions: Array<{
				id: string;
				batchIndex: number;
				clientId: string;
				chainId: string;
				from: string | null;
				transactionParams:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>;
				transactionHash: string | null;
				confirmedAt: string | null;
				confirmedAtBlockNumber: string | null;
				enrichedData:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>;
				executionParams:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>;
				executionResult:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>
					| null;
				createdAt: string;
				errorMessage: string | null;
				cancelledAt: string | null;
			}>;
			pagination: {
				totalCount: number;
				page: number;
				limit: number;
			};
		};
	};
};

export type SearchTransactionsResponse =
	SearchTransactionsResponses[keyof SearchTransactionsResponses];

export type GetActivityLogsData = {
	body?: never;
	path?: never;
	query: {
		page?: number;
		limit?: number;
		transactionId: string;
		batchIndex?: number;
		eventType?: "SUCCESS" | "FAILURE" | "NACK";
		stageName?: string;
		executorName?: string;
		sortBy?: "timestamp" | "createdAt";
		sortDirection?: "asc" | "desc";
	};
	url: "/v1/transactions/activity-logs";
};

export type GetActivityLogsErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Transaction not found or not accessible
	 */
	404: unknown;
};

export type GetActivityLogsResponses = {
	/**
	 * Activity Logs
	 */
	200: {
		result: {
			activityLogs: Array<{
				id: string;
				transactionId: string;
				batchIndex: number;
				eventType: string;
				stageName: string;
				executorName: string;
				notificationId: string;
				payload:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>;
				timestamp: string;
				createdAt: string;
			}>;
			transaction: {
				id: string;
				batchIndex: number;
				clientId: string;
			};
			pagination: {
				totalCount: number;
				page: number;
				limit: number;
			};
		};
	};
};

export type GetActivityLogsResponse =
	GetActivityLogsResponses[keyof GetActivityLogsResponses];

export type SearchActivityLogsData = {
	body?: {
		page?: number;
		limit?: number;
		transactionIds?: Array<string>;
		eventType?: "SUCCESS" | "FAILURE" | "NACK";
		stageName?: string;
		executorName?: string;
		startDate?: string;
		endDate?: string;
		sortBy?: "timestamp" | "createdAt";
		sortDirection?: "asc" | "desc";
	};
	path?: never;
	query?: never;
	url: "/v1/transactions/activity-logs/search";
};

export type SearchActivityLogsErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
};

export type SearchActivityLogsResponses = {
	/**
	 * Activity Logs Search Results
	 */
	200: {
		result: {
			activityLogs: Array<{
				id: string;
				transactionId: string;
				batchIndex: number;
				eventType: string;
				stageName: string;
				executorName: string;
				notificationId: string;
				payload:
					| (string | number | boolean | null)
					| {
							[key: string]: unknown;
					  }
					| Array<unknown>;
				timestamp: string;
				createdAt: string;
			}>;
			pagination: {
				totalCount: number;
				page: number;
				limit: number;
			};
		};
	};
};

export type SearchActivityLogsResponse =
	SearchActivityLogsResponses[keyof SearchActivityLogsResponses];

export type ClientOptions = {
	baseUrl: "https://engine.thirdweb.com" | (string & {});
};
