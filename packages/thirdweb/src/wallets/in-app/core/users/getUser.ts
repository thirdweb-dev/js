import type { ThirdwebClient } from "../../../../client/client.js";
import { getThirdwebBaseUrl } from "../../../../utils/domains.js";
import { getClientFetch } from "../../../../utils/fetch.js";
import type { OneOf, Prettify } from "../../../../utils/type-utils.js";
import type { Profile } from "../authentication/types.js";
import type { Ecosystem } from "../wallet/types.js";

export type GetUserResult = {
  userId: string;
  walletAddress: string;
  smartAccountAddress?: string;
  email?: string;
  phone?: string;
  createdAt: string;
  profiles: Profile[];
};

/**
 * Gets user based on the provided query parameters.
 *  This function is only available on the server (a secret key is required in the client).
 *
 * @param options - The options for the get user function.
 * @param options.client - The Thirdweb client with a secret key included.
 * @param [options.walletAddress] - The wallet address generated by thirdweb to query by.
 * @param [options.email] - The email to query by.
 * @param [options.phone] - The phone number to query by.
 * @param [options.id] - The user ID to query by.
 * @param [options.externalWalletAddress] - The linked external wallet address to query by.
 *
 * @returns A user object or null if not found.
 *
 * @example
 * import { getUser } from "thirdweb/wallets";
 *
 * const user = await getUser({
 *   client,
 *   walletAddress: "0x123...",
 * });
 *
 * @wallet
 */
export async function getUser({
  client,
  walletAddress,
  email,
  phone,
  id,
  externalWalletAddress,
  ecosystem,
}: Prettify<
  {
    client: ThirdwebClient;
    ecosystem?: Ecosystem;
  } & OneOf<{
    walletAddress?: string;
    email?: string;
    phone?: string;
    id?: string;
    externalWalletAddress?: string;
  }>
>): Promise<GetUserResult | null> {
  if (!client.secretKey) {
    throw new Error(
      "A secret key is required to query for users. If you're making this request from the server, please add a secret key to your client.",
    );
  }

  const url = new URL(
    `${getThirdwebBaseUrl("inAppWallet")}/api/2023-11-30/embedded-wallet/user-details`,
  );

  if (walletAddress) {
    url.searchParams.set("queryBy", "walletAddress");
    url.searchParams.set("walletAddress", walletAddress);
  } else if (email) {
    url.searchParams.set("queryBy", "email");
    url.searchParams.set("email", email);
  } else if (phone) {
    url.searchParams.set("queryBy", "phone");
    url.searchParams.set("phone", phone);
  } else if (id) {
    url.searchParams.set("queryBy", "id");
    url.searchParams.set("id", id);
  } else if (externalWalletAddress) {
    url.searchParams.set("queryBy", "externalWalletAddress");
    url.searchParams.set("externalWalletAddress", externalWalletAddress);
  } else {
    throw new Error(
      "Please provide a walletAddress, email, phone, id, or externalWalletAddress to query for users.",
    );
  }

  const clientFetch = getClientFetch(client, ecosystem);

  const res = await clientFetch(url.toString());

  if (!res.ok) {
    const error = await res.text().catch(() => "Unknown error");
    throw new Error(
      `Failed to get profiles. ${res.status} ${res.statusText}: ${error}`,
    );
  }

  const data = (await res.json()) as {
    userId: string;
    walletAddress: string;
    smartAccountAddress?: string;
    email?: string;
    phone?: string;
    createdAt: string;
    linkedAccounts: Profile[];
  }[];

  return (
    data.map((item) => ({
      createdAt: item.createdAt,
      email: item.email,
      phone: item.phone,
      profiles: item.linkedAccounts.map((profile) => {
        return {
          details: profile.details,
          type: (profile.type as string) === "siwe" ? "wallet" : profile.type,
        };
      }),
      smartAccountAddress: item.smartAccountAddress,
      userId: item.userId,
      walletAddress: item.walletAddress,
    }))[0] || null
  );
}
